% !TEX root = ../thesis.tex

\chapter{Previous Work}\label{cha:prev}
This chapter provides an overview of what my workings on the initial \gls{CPU} included.

\section{Design Goal}
My initial goal was to design a \gls{CPU} from scratch without explicitly looking at how other architectures had solved occurring problems.
This meant I was to rely on the knowledge I had achieved until then and came up with the following specifications I wanted my \gls{CPU} to fulfill:
\paragraph{8 bit bus width}
Most current era \glspl{CPU} employ a 32 bit or 64 bit bus to handle large numbers and large amounts of data.
It was clear to me that I needed to settle for a smaller bus when building a \gls{CPU} by hand.
Some early \glspl{CPU} worked with only 4 bits but to not be as limited I finally chose to use an 8 bit bus.
\paragraph{Datapath Architecture - Multicycle CISC}
In most \glspl{CPU} an instruction is not done in one clock cycle but it is divided into several steps that are done in sequence.
There are two general approaches that are called \emph{Multicycle} and \emph{Pipelining} \cite{PattersonDavid2016RuRD}.
Multicycle means that all the steps of one instruction are performed sequentially and a new instruction is only dispatched after the previous instruction is finished.
This is usually used when implementing \glspl{CISC}, where one instruction can be very capable \cite{chen_novick_shimano_2000}.
For example a add instruction in \gls{CISC} could fetch operands from memory, execute the add and write the result back to memory.
\glspl{RISC} on the other hand would need independent instruction to load operands from memory into registers, do the addition and write the result back to memory.

In Pipelining there a fixed steps each instruction goes through in a defined order and the intermediate results are stored in so called pipeline registers.
Each pipeline step is constructed in such a way that it does not intervene with the others.
Therefore, it is possible to dispatch a new instruction each cycle even though the previous instruction is not yet finished.
A typically 5-step pipeline would consist of the following steps \cite{PattersonDavid2016RuRD}:
\begin{enumerate}
  \item \textbf{Instruction Fetch}: The instruction is retrieved from memory and stored in a register.
  \item \textbf{Instruction Decode}: The fetched instruction is decoded into control signals (and instruction specific data) for all the components of the \gls{CPU}.
  \item \textbf{Execute}: If arithmetic or logical operations are part of the instruction, they are performed.
  \item \textbf{Memory Access}: Results are written to the memory and/or data is read from memory.
  \item \textbf{Writeback}: The results are written back to the registers.
\end{enumerate}
However good the performance of a pipelined \gls{CPU} is, it also comes with challenges.
Those include a greater resource usage because all intermediate results need to be stored in pipeline registers.
Additionally, branch instructions\footnote{Branch Instructions change the program counter and with that the location from which the next instruction is to be fetched. This is required for conditional and looped execution.} pose a great challenge because at the moment, the \gls{CPU} execute the branch the next instructions have already been dispatched.
This means that the pipeline needs to be flushed (i.e. cleared), performance is lost and more logic is required.
It also noteworthy that branch prediction and pipeline flushes can be quite vulnerable as recently shown in CVE-2017-5753 with the Spectre bug \cite{CVE-2017-5753}.

Therefore, I decided to build my \gls{CPU} as a Multicycle \gls{CISC}.

\paragraph{Single-Bus Oriented}
The decision for a Multicycle \gls{CPU} also enabled the architecture to be single-bus oriented.
This means that all modules (e.g. the \gls{ALU} and the memory) are connected to a central bus for data transfer.
The central bus is then used as a multi-directional data communication.
To allow this in hardware, all components that drive the bus (i.e. ``send'' data) need to have a tri-state driver.
A tri-state driver can either drive the bus with a defined `0' or `1' or high impedance which allows other tri-state drivers on the same bus to drive it.
That way an instruction which fetches a word from the memory from an address stored in a register and stores it in a register could consist of the following steps:
\begin{enumerate}
  \item Instruction Fetch
  \item Instruction Decode
  \item Memory Address from register over \emph{bus} to memory module
  \item Memory Access
  \item Data from memory module over \emph{bus} to register
\end{enumerate}
With such an architecture it is possible to avoid large multiplexers and keep the overall architecture simple.

\section{Implementation}
As mentioned above, the \gls{CPU} is divided into multiple modules which are only connected over the bus apart from control signals and one other exception.
\subsection{Modules}
The original design was split into 7 independent modules of varying complexity.
\subsubsection{\glsxtrfull{ALU}}
\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.25}
  \caption{Summary of the available alu operations.}
  \label{tab:aluOp}
  \begin{tabularx}{.8\textwidth}{ |c|c|c||X| }
    \hline
    aluOp[1] & aluOp[0] & aluSub & Resulting Operation\\\hline\hline
    0 & 0 & 0 & ($A + B$) Addition \\\hline
    0 & 0 & 1 & ($A - B$) Subtraction \\\hline
    0 & 1 & 0 & ($A \land B$) AND \\\hline
    0 & 1 & 1 & ($A \land \overline{B}$) \\\hline
    1 & 0 & 0 & ($A \veebar B$) XOR \\\hline
    1 & 0 & 1 & ($\overline{A \veebar B}$) XNOR \\\hline
    1 & 1 & 0 & ($A \gg B$) logical shift right \\\hline
    1 & 1 & 1 & ($A \ll B$) logical shift left \\\hline
  \end{tabularx}
\end{table}
The \gls{ALU} is capable of 4 different operations plus inverting the $B$ input for two's complement subtraction.
Therefore, there are three control signals which control the operation: two alu-operation bits plus one subtract bit.
The $B$ input is XORed with the aluSub bit which results in the $B$ input being inverted when aluSub is `1' and otherwise $B$ remains the same.
The aluSub bit is also connected to the carry input of the adder and with that, results in a two's complement subtraction.
All possible operations are shown in \cref{tab:aluOp}.
\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{full_adder.pdf}
  \caption{1 bit full adder with the usual A, B and Carry inputs and Y and Carry outputs as well as the XOR and AND outputs.}
  \label{fig:full_adder}
\end{figure}
The adder is a simple ripple carry adder for its simplicity and the XOR and AND operation from the half-adders are also used as the logic operations.
A complete 1 bit full-adder is shown in \cref{fig:full_adder}.

\begin{figure}[p]
  \centering
  \includegraphics[width=\textheight, angle=90]{barrel_shifter.pdf}
  \caption{8 bit bidirectional barrel shifter.}
  \label{fig:barrel_shifter}
\end{figure}
It was desirable to include a barrel shifter to have the possibility to improve multiply operation with a shift and add approach instead of repeated addition.
The barrel shifter works by 3 consecutive multiplexers to shift by 1, 2 or 4 bit to the right that are controlled by the first 3 bit of the (not inverted) $B$ input.
To also allow shifting to the left there is one multiplexer before the three shift multiplexers to invert the order of bits and another one after the shifting to reorder the bits.
In \cref{fig:barrel_shifter} a bidirectional barrel shifter implemented with the \texttt{74F157} is visualized. The \texttt{74F157} implements four 2 to 1 multiplexer and, therefore, 2 chips are needed for a full 8 bit 2 to 1 multiplexer.

The multiplexed result is stored in an 8 bit \gls{ALU} result register.
For conditional execution the \gls{ALU} includes two flags: Not Zero (at least one bit is one) and negative (the \gls{MSB}).

\subsubsection{Register File}
As is typical with \glspl{CISC} the \gls{CPU} does not need many general purpose registers and the register file can be kept simple with only two registers.
The register file has one write port (from the bus) and two read ports of which one reads to the bus and the other is directly connected to the $A$ input of the \gls{ALU}.
\subsubsection{Control Logic}\label{ssec:cl}
The control logic's job is to decode the current instruction and provide all the control signals for each cycle for any instruction.
For keeping track which cycle of each instruction is currently executing a 3 bit synchronous counter is needed.
Each control signal could be derived by a logical circuitry with 13 inputs: 8 bits instruction, 2 bits \gls{ALU} flags and 3 bits cycle counter.
However, designing these logic circuits is a lot of work, takes up a lot of space and cannot be changed easily later on. (For example when finding a bug in one instruction)
Therefore, an \gls{EEPROM} is used where the 13 bits that define one cycle of one specific instruction are used as addresses.
The control signals then are the data bits of the word that is stored at the specific address in the \gls{EEPROM}.

The first two cycles of each instruction need to be taken in special consideration because the instruction register is not yet loaded with the next instruction, because it is still being fetched and decoded.
However, the instruction fetch and decode are always the same for each instruction, which means that all memory locations where the cycle counter is equal to 0 or 1 (the first two instructions) are filled with the control signals for an instruction fetch and decode.
\subsubsection{Memory}
The memory module contains the main memory of the \gls{CPU} in form of an asynchronous \gls{SRAM} and the instruction memory as an \gls{EEPROM}.
This way a new program can be loaded into the \gls{CPU} by reprogramming the \gls{EEPROM}.
Both the \gls{SRAM} and the \gls{EEPROM} have their data lanes connected to the bus for reading from and writing to the memory.
The address is controlled via an \gls{MAR} from the bus.
\subsubsection{Program Counter}
The program counter is a special register with two main functionalities:\\
Usually it increments by one after each instruction.
However, when a branch is executed it needs to load the branch address from the bus.
For this an 8 bit increment similar to the cycle counter from the Control Logic \cref{ssec:cl} is multiplexed with the bus and used as the input data for the register.
\subsubsection{Input \& Output}
This first version of the \gls{CPU} included very rudimentary I/O logic.
For input it provides an 8 bit DIP-Switch connected to the bus and for output there is a register with a 2 digit 7-segment display.
\subsubsection{Clock \& Reset}
The function of the clock module is threefold:\\
It provides a clock for the whole \gls{CPU} while also providing an active-low reset for some of the registers to provide a defined starting condition.
The clock has two modes. One to run continuously and another where the clock can be manually advanced.
Additionally, there is a halt instruction which stops the \gls{CPU} clock until a button is pressed.
\subsection{FPGA Simulation}
The goal of the \gls{FPGA} simulation is to proof the general workings of the \gls{CPU} architecture.
There was no attempt made to provide a chip-level simulation of the hardware build but rather to provide a top-level behavioral model.
The chosen development environment is the AMD - Xilinx Vivado \cite{vivado} as it is freely available and provides an advanced simulation environment while providing the possibility to synthesize for relatively cheap \glspl{FPGA}.

\subsection{Hardware Build}

The clock circuit is heavily inspired by the clock module of the above mentioned YouTube series by Ben Eater \cite{eater_clock}.