% !TEX root = ../thesis.tex
\chapter{Software Development Environment}\label{cha:software}
When just providing the hardware, the \gls{CPU} can hardly be used.
It is possible to write programs by hand by writing single bytes to the \glspl{EEPROM} that hold the program.
However, it is quite infeasible to write complex programs this way.
Even more extreme is content of the \glspl{EEPROM} holding the micro code, i.e. that decode the instruction depending on the instruction cycle and \gls{ALU} flags.

Therefore, the \gls{EDiC} comes with two main software utilities that form the Software Development Environment.

\section{Microcode Generation}\label{sec:microcode}
\begin{listing}[t]
  \inputminted[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{TypeScript}{src/microcode.ts}
  \caption{Schema of the Microcode Definition CSON-File \cite{CSON} as a TypeScript \cite{TS} Type definition.}
  \label{lst:micrcode_schema}
\end{listing}
The goal is to define all the available instructions and what they perform in which instruction step and then have a program automatically generate the bit-files for the \gls{EEPROM}.
This approach allows to easily make changes to the existing microcode if a bug was found or a new instruction should be added.
The file format which defines the microcode has to be human and machine readable as it should be easily edited by hand and also be read by the tool that generates the bit-files.
A very common file format for tasks like this is \gls{JSON} \cite{JSON} which is widely used in the computer industry.
Besides basic types as strings and numbers, it allows basic arrays with square brackets (\texttt{[]}) and objects with curly braces (\texttt{\{\}}).
Each object contains key value pairs and everything can be nested as desired.
For the \gls{EDiC} microcode generation \gls{CSON} was used which is very similar to \gls{JSON} but is slightly easier to write by hand because its syntax is changed a bit:
\begin{itemize}
  \item It allows comments which is extensively used to ease the understanding of individual instruction steps
  \item Braces and commas are not required
  \item Keys do not require string quotation marks
\end{itemize}
The schema for the file describing the microcode is shown in \cref{lst:micrcode_schema}.
The file is an object with three key, value pairs:
\paragraph{Signals}
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    name: 'reg0NWE'
    noOp: 1
  }
  \end{minted}
  \caption{Example of a control signal definition for the microcode generation.}
  \label{lst:mc_signals}
\end{listing}
The signals array consists of Objects that define the available control signals and the default value of the control signal.
\Cref{lst:mc_signals}
defines the \emph{not write enable signal for register 0} control signal and defines the default state as high.
This means, when this control signal is not specified it will stay high and, therefore, register 0 will not be written.

\paragraph{InstructionFetch} This array defines the steps that are performed at the beginning of each instruction to fetch the new instruction and decode it.
Each object represents one step and consists of key value pairs that define one control signal.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
    instructionFetch: [
      { # write instruction
        memInstrNWE: 0
      }
      { # increment PC
        memPCNEn: 0
        memPCLoadN: 1
      }
    ]
  \end{minted}
  \caption{Definition of the instruction fetch and decode steps for the microcode generation.}
  \label{lst:mc_instrFetch}
\end{listing}

For example \cref{lst:mc_instrFetch} he first step specifies only the \emph{instruction not write enable} to be low and with this write the instruction into the instruction register.
Secondly, the \gls{PC} is incremented by setting \emph{PC not enable} to low and \emph{PC not load} to high.
\paragraph{Instructions} The instructions are an array of all available instructions.
Each instruction is defined as an \texttt{op} code, which is the 8 bit instruction in binary format.
However, if it was only possible to define the 8 bit as 0s and 1s instructions which only differ in the register used would need to be specified separately which is very error prone.
Therefore, it is allowed to specify the bit that specifies if register 0 or 1 is used to be set to \texttt{'r'} or \texttt{'s'} and then multiple instructions are generated.
Each instruction then The \texttt{cycles} array define the steps each instruction does in the same way as the \texttt{instructionFetch} array does.
However, as the value of individual control signals may depend up on which register is specified in the op code, it is also possible to specify \texttt{'r'}, \texttt{'!r'}, \texttt{'s'} or \texttt{'!s'}.

\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '1111100r' # r = imm
    cycles: [
      { # imm to bus to r
        reg0NWE: 'r'
        reg1NWE: '!r'
        memInstrNOE: 0
      }
    ]
  }
  \end{minted}
  \caption{Definition of the move immediate to register instruction for the microcode generation.}
  \label{lst:mc_movImm}
\end{listing}
\Cref{lst:mc_movImm} defines the move immediate to register instruction for both register at the same time.
The \emph{instruction immediate not output enable} is low and either register 0 or register 1 is written to.
This definition would be equal to \cref{lst:mc_movImmDuplicate}.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  [
    {
      op: '11111000' # r0 = imm
      cycles: [
        { # imm to bus to r0
          reg0NWE: 0
          reg1NWE: 1
          memInstrNOE: 0
        }
      ]
    }
    {
      op: '11111001' # r1 = imm
      cycles: [
        { # imm to bus to r1
          reg0NWE: 1
          reg1NWE: 0
          memInstrNOE: 0
        }
      ]
    }
  ]
  \end{minted}
  \caption{Definitions of the move immediate to register instruction for each register separately for the microcode generation.}
  \label{lst:mc_movImmDuplicate}
\end{listing}

This example is quite simple, however, instructions with two registers as arguments would result in four times the same definition and duplication can always result in inconsistencies.
The same idea is also used for the \gls{ALU} operations.
The \gls{ALU} operations are not generated by the microcode but are rather the three least significant bits of the instruction.
Therefore, all instructions using the \gls{ALU} can have the exact same control signals stored in the microcode \gls{EEPROM}.
To avoid 8 definitions of the same instructions, the op code can contain \texttt{'alu'} and all 8 instructions are generated.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '000rsalu' # r = r x s (alu)
    cycles: [
      { # r x s into alu
        aluYNWE: 0
        reg0BusNOE: 's'
        reg1BusNOE: '!s'
        regAluSel: 'r'
      }
      { # alu into r
        aluNOE: 0
        reg0NWE: 'r'
        reg1NWE: '!r'
      }
    ]
  }
  \end{minted}
  \caption{Definition of the alu operation with two register arguments for the microcode generation.}
  \label{lst:mc_aluRS}
\end{listing}
\Cref{lst:mc_aluRS} for example defines the alu operation with two registers and defines all 32 instructions with the op codes \texttt{'00000000'} to \texttt{'00011111'}.

\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '1010flag' # pc := imm
    cycles: [
      { # imm to pc
        memPCNEn: 0
        memPCLoadN: 0
        memPCFromImm: 1
      }
    ]
  }
  \end{minted}
  \caption{Definition of the branch instructions.}
  \label{lst:mc_branch}
\end{listing}
There is one final specialty built into the Microcode Generator:
The \gls{EDiC} has a branch instruction which is either executed or treated as a no-operation depending on the current state of the \gls{ALU} flags.
For all other instructions, the flags are ignored and always executed\footnote{Meaning that all memory locations for the instruction and step counter, no matter the \gls{ALU} flags, store the operation.}.
For this special instruction, the last for bits replaced with \texttt{flag} define at which state of the \gls{ALU} flags, the branch should be executed.
The possible conditions are heavily inspired by the conditional execution of ARM \glspl{CPU}\cite{armCond} as the \gls{ALU} flag architecture is very similar.
The possible values for the \texttt{flag} field and their meanings are listed in \cref{tab:mc_flagMeanings}.
Especially for a \gls{CPU} with only 8 bits it is important to support unsigned and signed operations and with a complex microcode it is no problem to support all the different branch instructions and with it facilitate the application design.
\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.25}
  \caption{All available branch instructions with their op-code and microcode translation based on the \gls{ALU} flags explained in \cref{sec:aluFlags}.}
  \label{tab:mc_flagMeanings}
  \begin{tabularx}{\textwidth}{ |c|l|l|X| }
    \hline
    \texttt{flag} (OP-Code) & Assembler Instruction                & \gls{ALU} flags                 & Interpretation   \\\hline\hline
    \texttt{0000}           & \texttt{jmp}/\texttt{bal}/\texttt{b} & Any                             & Always           \\\hline
    \texttt{0001}           & \texttt{beq}                         & \texttt{Z==1}                   & Equal            \\\hline
    \texttt{0010}           & \texttt{bne}                         & \texttt{Z==0}                   & Not Equal        \\\hline
    \texttt{0011}           & \texttt{bcs}/\texttt{bhs}            & \texttt{C==1}                   & Unsigned $\geq$  \\\hline
    \texttt{0100}           & \texttt{bcc}/\texttt{blo}            & \texttt{C==0}                   & Unsigned $<$     \\\hline
    \texttt{0101}           & \texttt{bmi}                         & \texttt{N==1}                   & Negative         \\\hline
    \texttt{0110}           & \texttt{bpl}                         & \texttt{N==0}                   & Positive or Zero \\\hline
    \texttt{0111}           & \texttt{bvs}                         & \texttt{V==1}                   & Overflow         \\\hline
    \texttt{1000}           & \texttt{bvc}                         & \texttt{V==0}                   & No overflow      \\\hline
    \texttt{1001}           & \texttt{bhi}                         & \texttt{C==1} and \texttt{Z==0} & Unsigned $>$     \\\hline
    \texttt{1010}           & \texttt{bls}                         & \texttt{C==0} or \texttt{Z==1}  & Unsigned $\leq$  \\\hline
    \texttt{1011}           & \texttt{bge}                         & \texttt{N==V}                   & Signed $\geq$    \\\hline
    \texttt{1100}           & \texttt{blt}                         & \texttt{N!=V}                   & Signed $<$       \\\hline
    \texttt{1101}           & \texttt{bgt}                         & \texttt{Z==0} and \texttt{N==V} & Signed $>$       \\\hline
    \texttt{1110}           & \texttt{ble}                         & \texttt{Z==0} or \texttt{N!=V}  & Signed $\leq$    \\\hline
    \texttt{1111}           & -                                    & Any                             & Never (Not used) \\\hline
  \end{tabularx}
\end{table}

\section{Assembler}
The second software that is probably even more important is the assembler.
An assembler translates human readable instructions into the machine code, i.e. the bits that are stored in the instruction \glspl{EEPROM}.
For the \gls{EDiC} each instruction is 24 bits wide, with 8 bits instruction op code and 8 or 16 bits immediate value.
Even though assemblers usually only translate instructions one for one, they can have quite advanced features.
With an assembler, the programmer is no longer required to know the specific op codes for all instructions and set individual bits of the instructions which is very error prone.
The assembler for the \gls{EDiC}, therefore, allows easier programming with a simple text-based assembly syntax similar to the well-known ARM syntax.
\begin{listing}
  \inputminted[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{ARM}{src/prng.s}
  \caption{\gls{PRNG} written in the \gls{EDiC} Assembler.}
  \label{lst:asm_prng}
\end{listing}

\begin{listing}
  \inputminted[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{ARM}{src/prng_out.s}
  \caption{The output of the \gls{PRNG} of \cref{lst:asm_prng}. The first 16 bits are the memory address, then 8 bits for the instruction op-code and 16 bits for the instruction immediate and for reference the original instruction with variables replaced.}
  \label{lst:asm_prng_out}
\end{listing}

\Cref{lst:asm_prng,lst:asm_prng_out} show the translation that the assembler does where \cref{lst:asm_prng} shows the assembler program that is written by any programmer and \cref{lst:asm_prng_out} summarizes what values are stored in the program \gls{EEPROM}.

\subsection{Available Instructions}
First of all, this section summarizes all available instructions and which parameters they take.
All instructions start with the operation and then up two parameters separated by a comma.

There are four different parameter types.
It can either be a register specified as \texttt{r0} or \texttt{r1}.
The register value can also be passed as the address to a memory operation with \texttt{[r0]}.

Immediate values can also be specified as value or as address with brackets around the immediate value.
However, the syntax for immediate values is more complex, as the assembler can parse decimal (positive and negative) as well as hexadecimal numbers.
Additionally, variables can be used which are further explained in \cref{sec:variables}.
When specifying a value, the immediate can range between -127 and 255 (two's complement and unsigned) and when used as an address it can range between 0 and 0xfffe (65534). The upper limit is not 0xffff because that address is reserved for the return address and should not be overwritten.
\paragraph{\gls{ALU} Instructions} The following \gls{ALU} instructions are available:
\begin{multicols}{4}
  \begin{itemize}
    \item add
    \item sub
    \item and
    \item eor
    \item xor
    \item xnor
    \item lsr
    \item lsl
  \end{itemize}
\end{multicols}
\gls{ALU} instructions always take two parameters. The first parameter is the left hand side operand and the register where the result is stored in and the second parameter is the right hand side operand.
\begin{itemize}
  \item Two registers

  \qquad\texttt{sub r0, r1} does: $r_0:=r_0-r_1$
  \item One register and one register as memory address

  \qquad\texttt{lsr r1, [r0]} does: $r_1:=r_1\gg\text{mem}[r_0]$
  \item One register and an immediate value

  \qquad\texttt{and r0, 0x0f} does: $r_0:=r_0\xor 15$
  \item One register and an immediate value as memory address

  \qquad\texttt{add r1, [0x0542]} does: $r_1:=r_1+\text{mem}[1346]$
\end{itemize}
All of the \gls{ALU} instructions can have an `s' as suffix which has the effect that the result of the operation is not written to the first operand.
This is useful when a calculation is only performed to update the \gls{ALU} flags but the register value is used later on.
This results in a special \gls{ALU} instruction: \texttt{cmp} which is an alias to \texttt{subs} which is typically used to compare to values and perform a branch instruction based on the result.
\begin{minted}{ARM}
cmp r0, 10
blt 0x42
\end{minted}
compares the \texttt{r0} register with the value 10 and if $r0 < 10\nicefrac{12}{13\pi}$ branches to instruction at address 66 and preserves the content of \texttt{r0}.
\subsection{Variables}\label{sec:variables}
\subsection{Syntax Definition for VS Code}