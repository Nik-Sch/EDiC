% !TEX root = ../thesis.tex
\chapter{Software Development Environment}\label{cha:software}
When just providing the hardware, the \gls{CPU} can hardly be used.
It is possible to write programs by hand by writing single bytes to the \glspl{EEPROM} that hold the program.
However, it is quite infeasible to write complex programs this way.
Even more extreme is content of the \glspl{EEPROM} holding the micro code, i.e. that decode the instruction depending on the instruction cycle and \gls{ALU} flags.

Therefore, the \gls{EDiC} comes with two main software utilities that form the Software Development Environment.

\section{Microcode Generation}
\begin{listing}[t]
  \inputminted[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{TypeScript}{src/microcode.ts}
  \caption{Schema of the Microcode Definition CSON-File \cite{CSON} as a TypeScript \cite{TS} Type definition.}
  \label{lst:micrcode_schema}
\end{listing}
The goal is to define all the available instructions and what they perform in which instruction step and then have a program automatically generate the bit-files for the \gls{EEPROM}.
This approach allows to easily make changes to the existing microcode if a bug was found or a new instruction should be added.
The file format which defines the microcode has to be human and machine readable as it should be easily edited by hand and also be read by the tool that generates the bit-files.
A very common file format for tasks like this is \gls{JSON} \cite{JSON} which is widely used in the computer industry.
Besides basic types as strings and numbers, it allows basic arrays with square brackets (\texttt{[]}) and objects with curly braces (\texttt{\{\}}).
Each object contains key value pairs and everything can be nested as desired.
For the \gls{EDiC} microcode generation \gls{CSON} was used which is very similar to \gls{JSON} but is slightly easier to write by hand because its syntax is changed a bit:
\begin{itemize}
  \item It allows comments which is extensively used to ease the understanding of individual instruction steps
  \item Braces and commas are not required
  \item Keys do not require string quotation marks
\end{itemize}
The schema for the file describing the microcode is shown in \cref{lst:micrcode_schema}.
The file is an object with three key, value pairs:
\paragraph{Signals}
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    name: 'reg0NWE'
    noOp: 1
  }
  \end{minted}
  \caption{Example of a control signal definition for the microcode generation.}
  \label{lst:mc_signals}
\end{listing}
The signals array consists of Objects that define the available control signals and the default value of the control signal.
\Cref{lst:mc_signals}
defines the \emph{not write enable signal for register 0} control signal and defines the default state as high.
This means, when this control signal is not specified it will stay high and, therefore, register 0 will not be written.

\paragraph{InstructionFetch} This array defines the steps that are performed at the beginning of each instruction to fetch the new instruction and decode it.
Each object represents one step and consists of key value pairs that define one control signal.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
    instructionFetch: [
      { # write instruction
        memInstrNWE: 0
      }
      { # increment PC
        memPCNEn: 0
        memPCLoadN: 1
      }
    ]
  \end{minted}
  \caption{Definition of the instruction fetch and decode steps for the microcode generation.}
  \label{lst:mc_instrFetch}
\end{listing}

For example \cref{lst:mc_instrFetch} he first step specifies only the \emph{instruction not write enable} to be low and with this write the instruction into the instruction register.
Secondly, the \gls{PC} is incremented by setting \emph{PC not enable} to low and \emph{PC not load} to high.
\paragraph{Instructions} The instructions are an array of all available instructions.
Each instruction is defined as an \texttt{op} code, which is the 8 bit instruction in binary format.
However, if it was only possible to define the 8 bit as 0s and 1s instructions which only differ in the register used would need to be specified separately which is very error prone.
Therefore, it is allowed to specify the bit that specifies if register 0 or 1 is used to be set to \texttt{'r'} or \texttt{'s'} and then multiple instructions are generated.
Each instruction then The \texttt{cycles} array define the steps each instruction does in the same way as the \texttt{instructionFetch} array does.
However, as the value of individual control signals may depend up on which register is specified in the op code, it is also possible to specify \texttt{'r'}, \texttt{'!r'}, \texttt{'s'} or \texttt{'!s'}.

\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '1111100r' # r = imm
    cycles: [
      { # imm to bus to r
        reg0NWE: 'r'
        reg1NWE: '!r'
        memInstrNOE: 0
      }
    ]
  }
  \end{minted}
  \caption{Definition of the move immediate to register instruction for the microcode generation.}
  \label{lst:mc_movImm}
\end{listing}
\Cref{lst:mc_movImm} defines the move immediate to register instruction for both register at the same time.
The \emph{instruction immediate not output enable} is low and either register 0 or register 1 is written to.
This definition would be equal to \cref{lst:mc_movImmDuplicate}.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  [
    {
      op: '11111000' # r0 = imm
      cycles: [
        { # imm to bus to r0
          reg0NWE: 0
          reg1NWE: 1
          memInstrNOE: 0
        }
      ]
    }
    {
      op: '11111001' # r1 = imm
      cycles: [
        { # imm to bus to r1
          reg0NWE: 1
          reg1NWE: 0
          memInstrNOE: 0
        }
      ]
    }
  ]
  \end{minted}
  \caption{Definitions of the move immediate to register instruction for each register separately for the microcode generation.}
  \label{lst:mc_movImmDuplicate}
\end{listing}

This example is quite simple, however, instructions with two registers as arguments would result in four times the same definition and duplication can always result in inconsistencies.
The same idea is also used for the \gls{ALU} operations.
The \gls{ALU} operations are not generated by the microcode but are rather the three least significant bits of the instruction.
Therefore, all instructions using the \gls{ALU} can have the exact same control signals stored in the microcode \gls{EEPROM}.
To avoid 8 definitions of the same instructions, the op code can contain \texttt{'alu'} and all 8 instructions are generated.
\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '000rsalu' # r = r x s (alu)
    cycles: [
      { # r x s into alu
        aluYNWE: 0
        reg0BusNOE: 's'
        reg1BusNOE: '!s'
        regAluSel: 'r'
      }
      { # alu into r
        aluNOE: 0
        reg0NWE: 'r'
        reg1NWE: '!r'
      }
    ]
  }
  \end{minted}
  \caption{Definition of the alu operation with two register arguments for the microcode generation.}
  \label{lst:mc_aluRS}
\end{listing}
\Cref{lst:mc_aluRS} for example defines the alu operation with two registers and defines all 32 instructions with the op codes \texttt{'00000000'} to \texttt{'00011111'}.

\begin{listing}[h!]
  \begin{minted}[linenos,
    breaklines,
    frame=leftline,
    xleftmargin=20pt,
  ]{CoffeeScript}
  {
    op: '1010flag' # pc := imm
    cycles: [
      { # imm to pc
        memPCNEn: 0
        memPCLoadN: 0
        memPCFromImm: 1
      }
    ]
  }
  \end{minted}
  \caption{Definition of the branch instructions.}
  \label{lst:mc_branch}
\end{listing}
There is one final specialty built into the Microcode Generator:
The \gls{EDiC} has a branch instruction which is either executed or treated as a no-operation depending on the current state of the \gls{ALU} flags.
For all other instructions, the flags are ignored and always executed\footnote{Meaning that all memory locations for the instruction and step counter, no matter the \gls{ALU} flags, store the operation.}.
For this special instruction, the last for bits replaced with \texttt{flag} define at which state of the \gls{ALU} flags, the branch should be executed.
The possible conditions are heavily inspired by the conditional execution of ARM \glspl{CPU}\cite{armCond} as the \gls{ALU} flag architecture is very similar.
The possible values for the \texttt{flag} field and their meanings are listed in \cref{tab:mc_flagMeanings}.
Especially for a \gls{CPU} with only 8 bits it is important to support unsigned and signed operations and with a complex microcode it is no problem to support all the different branch instructions and with it facilitate the application design.
\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.25}
  \caption{All available branch instructions with their op-code and microcode translation based on the \gls{ALU} flags explained in \cref{sec:aluFlags}.}
  \label{tab:mc_flagMeanings}
  \begin{tabularx}{\textwidth}{ |c|l|l|X| }
    \hline
    \texttt{flag} (OP-Code) & Assembler Instruction                & \gls{ALU} flags                 & Interpretation   \\\hline\hline
    \texttt{0000} & \texttt{jmp}/\texttt{bal}/\texttt{b} & Any                             & Always           \\\hline
    \texttt{0001} & \texttt{beq}                         & \texttt{Z==1}                   & Equal            \\\hline
    \texttt{0010} & \texttt{bne}                         & \texttt{Z==0}                   & Not Equal        \\\hline
    \texttt{0011} & \texttt{bcs}/\texttt{bhs}            & \texttt{C==1}                   & Unsigned $\geq$  \\\hline
    \texttt{0100} & \texttt{bcc}/\texttt{blo}            & \texttt{C==0}                   & Unsigned $<$     \\\hline
    \texttt{0101} & \texttt{bmi}                         & \texttt{N==1}                   & Negative         \\\hline
    \texttt{0110} & \texttt{bpl}                         & \texttt{N==0}                   & Positive or Zero \\\hline
    \texttt{0111} & \texttt{bvs}                         & \texttt{V==1}                   & Overflow         \\\hline
    \texttt{1000} & \texttt{bvc}                         & \texttt{V==0}                   & No overflow      \\\hline
    \texttt{1001} & \texttt{bhi}                         & \texttt{C==1} and \texttt{Z==0} & Unsigned $>$     \\\hline
    \texttt{1010} & \texttt{bls}                         & \texttt{C==0} or \texttt{Z==1}  & Unsigned $\leq$  \\\hline
    \texttt{1011} & \texttt{bge}                         & \texttt{N==V}                   & Signed $\geq$    \\\hline
    \texttt{1100} & \texttt{blt}                         & \texttt{N!=V}                   & Signed $<$       \\\hline
    \texttt{1101} & \texttt{bgt}                         & \texttt{Z==0} and \texttt{N==V} & Signed $>$       \\\hline
    \texttt{1110} & \texttt{ble}                         & \texttt{Z==0} or \texttt{N!=V}  & Signed $\leq$    \\\hline
    \texttt{1111} & -                                    & Any                             & Never (Not used) \\\hline
  \end{tabularx}
\end{table}

\section{Assembler}
\subsection{Syntax Definition for VS Code}