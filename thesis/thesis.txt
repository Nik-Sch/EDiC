Master Thesis
Design and Implementation of a Model
CPU with Basic Logic Chips and related
Development Environment for
Educational Purposes
created by
Niklas Schelten
Matrikel: 376314
First examiner:

Prof. Dr.-Ing. Reinhold Orglmeister,
Chair of Electronics and Medical Signal Processing,
Technische Universität Berlin

Second examiner:

Prof. Dr.-Ing. Clemens Gühmann,
Chair of Electronic Measurement and Diagnostic Technology,
Technische Universität Berlin

Supervisor:

Dipl.-Ing. Henry Westphal,
Tigris Elektronik GmbH

22.06.2022

Eidesstattliche Erklärung
Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und eigenhändig
sowie ohne unerlaubte fremde Hilfe und ausschließlich unter Verwendung der aufgeführten Quellen und Hilfsmittel angefertigt habe.

Berlin, den 22.06.2022

Unterschrift

Contents
1 Introduction
1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1 Short History on Computing . . . . . . . . . . . . . . . . . .
1.1.2 Technology Selection for the Educational Digital Computer
(EDiC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.3 Workings of Transistor-transistor logic (TTL) . . . . . . . . .
1.2 Thesis Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
1
1

2 Architecture
2.1 Design Decisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 8 bit bus width . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Datapath Architecture - Multicycle CISC . . . . . . . . . . .
2.1.3 Single-Bus Oriented . . . . . . . . . . . . . . . . . . . . . . .
2.2 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1 Arithmetic Logic Unit (ALU) . . . . . . . . . . . . . . . . . .
2.2.2 Register File . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.3 Program Counter (PC) & Instruction Register . . . . . . . . .
2.2.4 Control Logic . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.5 Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.5.1 Memory Mapped Input / Output (I/O) . . . . . . .
2.2.5.2 Stack Implementation . . . . . . . . . . . . . . . . .
2.2.5.3 Addressing Logic . . . . . . . . . . . . . . . . . . . .
2.2.6 Input & Output . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.7 Clock, Reset & Debugging . . . . . . . . . . . . . . . . . . . .
2.3 Control Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Final Instruction Set . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1 ALU operations . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2 Memory operations . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3 Miscellaneous operations . . . . . . . . . . . . . . . . . . . . .

7
7
7
8
9
10
10
13
13
14
15
15
15
16
17
17
18
20
20
21
24

3
4
6

i

Contents
3 Software Development Environment
3.1 Microcode Generation . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Assembler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 Calling conventions . . . . . . . . . . . . . . . . . . . . . . . .
3.2.2 Available Instructions . . . . . . . . . . . . . . . . . . . . . .
3.2.2.1 ALU Instructions . . . . . . . . . . . . . . . . . . .
3.2.2.2 Memory Instructions . . . . . . . . . . . . . . . . . .
3.2.2.3 Miscellaneous Instructions . . . . . . . . . . . . . . .
3.2.3 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.3.1 Value constants . . . . . . . . . . . . . . . . . . . .
3.2.3.2 Labels . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.3.3 String constants . . . . . . . . . . . . . . . . . . . .
3.2.4 File imports . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.5 Syntax Definition for VS Code . . . . . . . . . . . . . . . . .

25
25
29
31
32
33
34
35
36
36
36
37
40
40

4 FPGA Model
4.1 FPGA Background . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 FPGA choices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1 Language Choice . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 Tri-state Logic in FPGAs . . . . . . . . . . . . . . . . . . . .
4.3 Behavioral Implementation . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Chip-level Implementation . . . . . . . . . . . . . . . . . . . . . . . .
4.4.1 Conversation Script . . . . . . . . . . . . . . . . . . . . . . .
4.4.1.1 EEPROM . . . . . . . . . . . . . . . . . . . . . . .
4.4.1.2 tri-state Ports . . . . . . . . . . . . . . . . . . . . .
4.4.1.3 RAM and EEPROM clock . . . . . . . . . . . . . .
4.4.1.4 Assignments . . . . . . . . . . . . . . . . . . . . . .
4.4.1.5 Display Driver . . . . . . . . . . . . . . . . . . . . .
4.4.2 RS232 I/O Extension Debugging . . . . . . . . . . . . . . . .

43
43
44
45
45
46
48
48
50
51
52
52
53
54

5 Hardware Design
5.1 Schematic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.1 Register Comparison . . . . . . . . . . . . . . . . . . . . . . .
5.1.2 LED Driver . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.3 Program Counter & Instruction EEPROMs . . . . . . . . . .
5.1.4 Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.5 Control Logic . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.6 Clock and Reset . . . . . . . . . . . . . . . . . . . . . . . . .
5.1.7 Built-In I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . .

57
57
57
59
60
60
61
61
62

ii

Contents
5.1.8 Register Set and ALU output . . . . . . . . . . . . . . . . . .
5.1.9 Combinatorial ALU . . . . . . . . . . . . . . . . . . . . . . .
Placing and Routing . . . . . . . . . . . . . . . . . . . . . . . . . . .
Timing Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

62
62
62
64

6 Initial Hardware Test & Component Verification
6.1 Test Adapter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Potential Complications . . . . . . . . . . . . . . . . . . . . . . . . .
6.2.1 Shifter - Carry Flag . . . . . . . . . . . . . . . . . . . . . . .
6.2.2 Clock jitter . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2.3 Driving Bus High . . . . . . . . . . . . . . . . . . . . . . . . .
6.2.4 UART Transceiver lost data . . . . . . . . . . . . . . . . . . .

73
73
74
74
76
77
79

7 Conclusion and Future Work

83

Acronyms

85

List of Figures

90

List of Tables

91

List of Code Examples

94

Bibliography

95

A Full Schematics of the EDiC

99

B Collection of assembler programs

115

5.2
5.3

Niklas Schelten

iii

Abstract
This thesis covers the implementation of the EDiC, a model Central Processing
Unit (CPU) which is to be used for teaching the workings of modern digital general
purpose processors. For the educational purposes an extensive software development
environment accompanies the novel CPU Instruction Set Architecture (ISA). The
thesis justifies the architectural design decisions which lead to the design of this
8 bit Complex Instruction Set Computer (CISC) multi-cycle CPU with a 16 bit
address space and comprehensive I/O support. The modularization of the CPU into
7 independent modules simplifies the process of understanding the details of the
CPU. Additionally, the choice of TTL Integrated Circuits (ICs) of the 74 family
takes the learning focus towards the digital level without complicating the design
with analog behavior as Register-transistor logic (RTL) would.
For functional verification, a behavioral and also a chip-level Field Programmable
Gate Array (FPGA) implementation is performed. The component verification is
eased with specially developed test adapter which allow for bit by bit testing of all
ICs and in-depth debugging. With a detailed timing analysis it is ensured that the
EDiC does not run into unpredictable timing problems.

v

Kurzfassung
Diese Arbeit beschreibt die Entwicklung und Implementierung vom Educational Digital Computer (EDiC), einer Model Central Processing Unit (CPU) welche speziell
für die Lehre entwickelt wurde. Sie soll dabei helfen die Funktionsweise eines modernen, allgemein benutzbaren Prozessors erklären. Dafür wird die neu entwickelte
Instruction Set Architecture (ISA) durch eine ausführliche Entwicklungsumgebung
unterstützt. Alle Design Entscheidungen, welche zu dieser 8 bit Complex Instruction
Set Computer (CISC) und multi-cycle CPU mit einem 16 bit Adressraum geführt
haben, werden ausführlich erklärt und abgewogen. Die Aufteilung in insgesamt 7
größtenteils unabhängige Module vereinfacht das Verständnis der Details der CPU
enorm. Zusätzlich wird das Verständnis durch die Wahl der Transistor-transistor
logic (TTL) Integrated Circuits (ICs) aus der 74er Familie auf die digitale Ebene gelenkt und nicht durch analoge Nebeneffekte wie bei Register-transistor logic (RTL)
abgelenkt.
Um die Funktionalität zu verifizieren wurde eine Verhaltensimplementierung und
auch eine Implementierung auf IC-level auf einem Field Programmable Gate Array
(FPGA) durchgeführt. The Verifikation der einzelnen Hardware Komponenten wird
durch speziell für den EDiC designte Test Adapter deutlich vereinfacht. Diese erlauben ein Bit für Bit testen von allen ICs und ausführliches debuggen der Schaltung.
Weiterhin wird durch eine detaillierte Timing-Analyse sichergestellt, dass beim EDiC
keine unvorhergesehenen Timing-Probleme auftreten werden.

vi

1 Introduction
This thesis covers the development and engineering process of the Educational Digital Computer (EDiC) pictured in figure 1.1. It is a completely novel Central Processing Unit (CPU) architecture built to visualize and show the fundamental workings
of any CPU. The EDiC can execute over half a million instructions per second and
also features step-by-step debugging as well as breakpoint capabilities for better understanding of how CPUs work. All components can be tested individually with the
help of dedicated test adapters and, therefore, Integrated Circuit (IC) failures can
be tracked down and fixed easily. Additionally to the hardware built, the project
includes an open source development environment including an assembler, tools to
modify the micro-code and also Field Programmable Gate Array (FPGA) simulation
and emulation of the hardware [11].

1.1 Background
1.1.1 Short History on Computing
The history of computing hardware goes back to ancient times with devices like
the abacus which simplifies calculations like additions or multiplications. Starting
from the end of 19th century, analog computers were developed which used continues physical phenomena to explore complex problems. One of the first wide
spread analog computers was developed by Sir William Thomson (Lord Kelvin)
which predicted tide levels for particular locations by using a set of pulleys and
wires. [5] Even though analog computers could perform very complex operations
like solving differential equations [17] they also had the major drawback that, due
to their analog and continues nature, it was not possible to exactly recreate a calculation.
The idea of modern, digital computers was firstly theorized by Alan Turing in his
paper On Computable Numbers in 1936. [28] He introduced the notion of a universal
(turing) machine which describes a machine which is provable capable of computing

1

1 Introduction

Figure 1.1: The final version of the EDiC playing Snake on a VT-100 over an
RS-232 I/O card.
everything that is computable. All of todays computer are as capable as a turing
machine which is expressed by calling them turing complete. This is with exception
from their finite memory and limited number range. The first digital computers
from the mid 20th century were mechanical or electromechanical machines which
combined basic switches like relays and mostly mechanical memory. As fully electrical computers increased the switching frequencies, many different number formats
where emerging: Opposed to analog computers where one signal, e.g. a voltage, represents a value, it now needs to encode a value. In the now common binary system
one signal encodes either a 0 or a 1 (for example a low and high voltage) but a lot
of different number systems where used like bi-quinary1 .
A lot of different technologies where developed for fully electric computers like vacuum tubes or transistors. After using discrete transistors, the advent of ICs in the
late 50th lead to a rapid acceleration of computer complexity and speed while reducing the power consumption drastically. The series of ICs which is the most relevant
1

Bi-Quinary has one quinary signal encoding 0-4 or 5-9 depending one one binary signal encoding a low or high number. This allows two signals to encode a decimal digit similarly to some
abacuses.

2

1.1 Background
to this thesis is the Transistor-transistor logic (TTL) 74 series. It was a successor of
one of the first TTL ICs developed by Texas Instruments in 1964 for military applications: The 5400 series. [29] The 5400 series of ICs were specified for a temperature
range of −55 ◦ C to 125 ◦ C and came in ceramic surface-mounted device (SMD) and
dual in-line (DIL) packaging to meet the high requirements of the military and space
industries. Each package included a set of basic logic circuits like a quad two input
NAND gate in the 5400N. In 1966 the first ICs of the 74 series were released which
had the same functions but with a reduced temperature rating of 0 ◦ C to 70 ◦ C and
often came in plastic packaging for consumer applications. In contrast to previous
Register-transistor logic (RTL), these TTL ICs were capable of higher switching frequencies and lower power consumption due to a second transistor driving the high
voltage level. See section 1.1.3 for a more in depth description of the workings of
a TTL gate. As the 74 family of ICs became larger with more complex ICs, more
advanced technologies were also introduced into the family to further reduce the
power consumption or increase the switching speeds with for example Complementary metal-oxide-semiconductor (CMOS) technology.
Further advancing the complexity and integration of computing nodes the first microprocessors were developed in the 70s with the famous Intel 4004 and 8080 in 1971
and 1974, respectively. These combine all the logic required for a general purpose
CPU into one IC usually exposing interfaces for connecting memories and user Input
/ Output (I/O) logic.

1.1.2 Technology Selection for the EDiC
The design goal for the EDiC was to design a CPU which aids the teaching of
how CPUs in general work. To build a custom CPU, many of the above mentioned
technologies were used for computer design, however, not all of them are equally
suited for a model CPU. It was decided to use TTL ICs of the 74 family in the
EDiC for several reasons:
• Complexity: The ICs of this family are complex enough that is possible to
build complex systems as a general-purpose CPU with only about 100 chips.
On the other hand, each individual IC is easy to understand because it is kept
quite simple, like the 7400 which has a simple interface of 12 pins for the four
2-input NAND gates plus GND and +5V pins.
• Speed: In contrast to previous technologies like electromechanical relays or
RTL, the 74 series is a lot faster, especially the 74F subseries which is mainly
used in the EDiC. It is quite possible to create complex designs with the

Niklas Schelten

3

1 Introduction
74F series with a clock frequency of several MHz. However, at the same time,
the clock frequency is not that high, that special care must be taken when
designing the Printed Circuit Board (PCB) which would be the case with
higher frequency signals.
• Simplicity: Working with the ICs is quite easy: No special tools except a soldering iron and oscilloscope are required to assemble and test the system.
Especially the usage of sockets for the dual in-line packages (DIPs) simplifies
the built because no IC can overheat while soldering and all the ICs can be
replaced later on or while testing.
In contrast to previous and also later technology the TTL also stands out as the
best suited one. When trying to build a CPU out of discrete transistors not only the
logical level needs to be respected but a lot of static and dynamic behavior of the
transistors needs to be analyzed. This complicates the design and prevents students
from comprehending the CPU on its logical level. On the other side, more modern
technologies became so abstract and complex to use that the comprehension of the
internal workings of the CPU could also be lost. For example, when choosing FPGAs
as the driving technology, the work surrounding the technology quickly becomes
more complex than the CPU itself. The FPGA IC require special voltage levels and
special care with the high frequency clock traces, are hard to solder with small pins,
require complex build toolchains, cannot be debugged with an oscilloscope and so
on.
Therefore, the TTL was the ideal technology level for creating a model CPU which
helps students understanding the workings of CPUs.

1.1.3 Workings of TTL
Figure 1.2 shows the internals of one of the four NAND gates inside the 7400 IC. The
multi-emitter transistor V1 functions as the logical NAND gate while the transistors
V2 , V3 and V4 in combination with the diode V5 form the “totem-pole” output stage.
If both inputs are high, a small collector current is drawn by both inputs because
V1 is in reverse-active mode. The current through R1 “activates” V2 which in turn
“activates” V4 due to the current steering effect, where the current flows through the
one parallel voltage-stable element with the lowest threshold voltage. In this case,
the current flows through R2 , V2 collector-emitter and V4 base-emitter rather than
through V3 collector-emitter, V5 and V4 collector-emitter. Therefore, V4 drives the
output with a low voltage.

4

1.1 Background

+5V

R2
1k6

R1
4k

R3
130

V3
V1

V2
V5

U1
V4
Ua

U2

R4
1k

Figure 1.2: TTL NAND with “totem-pole” output stage as in the 7400 IC. [21]
If one of the inputs is low, on the other hand, the current steering effect turns
off V2 because the current flows through R1 and V1 base-emitter rather than R1 ,
V1 base-collector V2 base-emitter and R4 . With that, the above mentioned current
steering effect on the output stage no longer takes effect and V3 drives the output
high through the diode V5 .
The advantage of this “totem-pole” output stage in comparison to a more simple
output stage with the collector of V2 effectively being the output is, that a very low
output resistance can be achieved (only the small R3 ) which allows the output to

Niklas Schelten

5

1 Introduction
drive more inputs of other logic gates. Additionally, the speed is drastically increased
because the high output is actively driven instead of pulled up with via a resistor
as in RTL. However, the voltage drop over V3 and V5 also have the effect the high
output voltage is only about 3.5 V in contrast to the simpler approach where close
to 5 V can be achieved.

1.2 Thesis Structure
The following chapter 2 will give an in-depth explanation of the CPU architecture.
It includes an analysis of the design goals and how they can be achieved. The
individual modules are described as well as how they work together to execute any
instruction.
With the focus on usability, the chapter 3 gives an overview of the software environment which eases the development of programs for the EDiC. It also features a tool
with which the microcode for instructions can be changed or new instructions can
be added which is especially important with respect to the educational purpose of
the model CPU.
Chapter 4 gives a short background to FPGAs and then covers all the important
aspects of the FPGA model which was created to verify the architecture. With a
chip-level FPGA implementation it was possible to not only verify the architecture
but also the schematic of the EDiC on the logical level.
In chapter 5 the hardware design is finally detailed. Besides an explanation of the
schematics (attached in appendix A), the chapter also contains information on the
development process of the PCB design.
After the PCB was designed and produced, the process of testing the components
and verifying all instructions is shown in chapter 6.
A final conclusion and possibilities for further work are then given in chapter 7.

6

2 Architecture
Designing and building a general purpose CPU includes a lot of architectural decisions which will decide how well the CPU performs, how complex it is and so on. The
goal for the EDiC was to build a CPU that is capable of interacting with extensible
I/O device such as the VT-100 but at the same time simple enough to easily understand its workings, such that it is suited to be used in education.

2.1 Design Decisions
First of all, there are several decisions about the general structure of a CPU that
need to be made. These decisions greatly influence how the EDiC can be structured
into modules and how the final hardware build is setup. Another important factor
towards architectural structure is the fact that the final hardware build of the CPU
is be based on the 74-series of TTL ICs.

2.1.1 8 bit bus width
Most current era CPUs employ a 32 bit or 64 bit bus to handle large numbers and
large amounts of data. This, however, is not feasible when using 74-series ICs and
at the same time targeting an easy to understand hardware build. Some early CPUs
build with similar ICs worked with only 4 bits. This can work very well for specific
applications but for the most arithmetics and data handling 8 bits are more practical.
The EDiC will, therefore, use an 8 bit bus for data with a integer range of -128 to
127 or 0 to 255 for unsigned integers.
One of the major limitation of an overall 8 bit bus is the addressable memory space.
With only 8 bit for the memory address, the maximum amount of memory addressable is 256 bytes. In a first prototype of the CPU the memory space was tripled by
providing 256 bytes of instruction memory besides 256 bytes of Read-Only Memory (ROM) for instruction immediate values and 256 bytes of addressable Static
Random-Access Memory (SRAM). However, especially with a Complex Instruction

7

2 Architecture
Set Computer (CISC) architecture (see section 2.1.2), the limited SRAM memory
space greatly limits the overall complexity of programs that can be executed. Additionally, more complex programs or even small operating systems are impossible to
fit into 256 instructions.
Therefore, it was decided to extend the Program Counter (PC) and the memory
addresses to 16 bit, which yields 65536 bytes of addressable SRAM and theoretically
65536 instructions1 . However, this raises problems of where the 16 bit addresses come
from when all the registers and the memory only store 8 bit. The solution for the
EDiC is presented in section 2.2.5.3 when explaining the different modules of the
EDiC.

2.1.2 Datapath Architecture - Multicycle CISC
In most CPUs an instruction is not done in one clock cycle but it is divided into
several steps that are done in sequence. There are two general approaches that
are called Multicycle and Pipelining [24]. Multicycle means that all the steps of one
instruction are performed sequentially and a new instruction is only dispatched after
the previous instruction is finished. This is usually used when implementing CISCs,
where one instruction can be very capable [4]. For example an add instruction in
CISC could fetch operands from memory, execute the add and write the result back
to memory. Reduced Instruction Set Computers (RISCs) on the other hand would
need three independent instruction to load operands from memory into registers, do
the addition and write the result back to memory.
In Pipelining there are fixed steps each instruction goes through in a defined order
and the intermediate results are stored in so called pipeline registers. Each pipeline
step is constructed in such a way that it does not intervene with the others. Therefore,
it is, in theory, possible to dispatch a new instruction each cycle even though the
previous instruction is not yet finished. A typically 5-step pipeline would consist of
the following steps [24]:
1. Instruction Fetch: The instruction is retrieved from memory and stored in
a register.
2. Instruction Decode: The fetched instruction is decoded into control signals
(and instruction specific data) for all the components of the CPU.
1

The largest feasible Electrically Erasable Programmable Read-Only Memory (EEPROM)
available used for instruction memory has only 15 address bits and with that only 32768 8 bit
words of data.

8

2.1 Design Decisions
3. Execute: If arithmetic or logical operations are part of the instruction, they
are performed.
4. Memory Access: Results are written to the memory and/or data is read
from memory.
5. Writeback: The results are written back to the registers.
However good the performance of a pipelined CPU is, it also comes with challenges.
Those include a greater resource usage because all intermediate results need to be
stored in pipeline registers. Additionally, branch instructions2 pose a greater challenge because at the moment, the CPU execute the branch the following instructions
have already been dispatched. This means that the pipeline needs to be flushed (i.e.
cleared), performance is lost and more logic is required. It also noteworthy that
branch prediction and pipeline flushes can be quite vulnerable as recently shown in
CVE-2017-5753 with the Spectre bug [7].
Therefore, the EDiC is to built as a Multicycle CISC.

2.1.3 Single-Bus Oriented
The decision for a Multicycle CPU also enabled the architecture to be single-bus
oriented. This means that all modules (e.g. the Arithmetic Logic Unit (ALU) or
the memory) are connected to a central bus for data transfer. The central bus is
then used as a multi-directional data communication. To allow this in hardware, all
components that drive the bus (i.e. “send” data) need to have a tri-state driver. A
tri-state driver can either drive the bus with a defined ‘0’ (low voltage) or ‘1’ (high
voltage) or not drive the bus (high impedance) which allows other tri-state drivers
on the same bus to drive it. That way an instruction which fetches a word from the
memory from an address stored in a register, adds a register value to it and stores
it in a register could consist of the following steps:
1. Instruction Fetch
2. Instruction Decode
3. Memory Address from register over bus to memory module
4. Memory Access
5. Data from memory module over bus to ALU input
2

Branch Instructions change the PC and with that the location from which the next instruction
is to be fetched. This is required for conditional and looped execution.

Niklas Schelten

9

2 Architecture

Cin
Y
A
and
B
Cout

xor

Figure 2.1: 1 bit full adder with the usual A, B and Carry inputs and Y and
Carry outputs as well as the XOR and AND outputs.
6. ALU operation
7. Data from ALU output over bus to register
With such an architecture it is possible to avoid large multiplexers and keep the
overall architecture simple.

2.2 Modules
The design has been split into 7 rather independent modules of varying complexity which mainly interface with each other over the bus and control signals.

2.2.1 Arithmetic Logic Unit (ALU)
An ALU is the computational core of any CPU as it performs all the calculations.
The ALU of the EDiC is by design simple with only 4 different operations plus
an option to invert the second input. The result of the ALU is stored in a result
register which can drive the bus to store the result in a register or memory. For
simplicity, the first input of the ALU (A input) is directly connected to the register
file (section 2.2.2) and only the second input (B input) is accessible from the bus.
This limits the possibilities of instructions, however, if both inputs should have
been driven by the bus, every ALU instruction would have taken three instead of
two cycle limited by the bus (first cycle A input, second cycle B input, third cycle
result).

10

2.2 Modules

Table 2.1: Summary of the available ALU operations.
aluOp[1]

aluOp[0]

aluSub

Resulting Operation

0

0

0

(A + B) Addition

0

0

1

(A − B) Subtraction

0

1

0

(A ∧ B) AND

0

1

1

(A ∧ B)

1

0

0

(A ⊻ B) XOR

1

0

1

(A ⊻ B) XNOR

1

1

0

(A ≫ B) logical shift right

1

1

1

(A ≪ B) logical shift left

The ALU consists of an 8 bit ripple carry full adder and a barrel shifter. The operations are controlled by three control signals: The first two bits select which ALU
operation to perform and the third bit modifies the operation to perform. The possible operations are shown in table 2.1. For the adder, the third bit inverts the B
input when active (All input bits are XORed with the control bit) and is used as the
carry in of the adder. This negates the B input in twos complement and, therefore,
subtracts it from the A input. For the barrel shifter, the third bit reverses the shift
direction.
The XOR and AND operations shown in table 2.1 are chosen because they
are already implemented in the half-adders and no additional logic is required
to implement them. A complete 1 bit full-adder of the EDiC is shown in figure 2.1.
It was desirable to include a barrel shifter to have the possibility to improve multiply
operation with a shift and add approach instead of repeated addition. The barrel
shifter works by 3 consecutive multiplexers shifting by 1, 2 or 4 bit to the right that
are controlled by the first 3 bit of the (not inverted) B input. To also allow shifting
to the left there is one multiplexer before the three shift multiplexers to invert the
order of bits and another one after the shifting to reorder the bits. In figure 2.2 a
bidirectional barrel shifter implemented with the 74F157 is visualized. The 74F157
implements four 2 to 1 multiplexer and, therefore, 2 chips are needed for a full 8 bit
2 to 1 multiplexer.
The ALU also provides four flags which are used for condition execution. The Zero
(all result bits are zero) and Negative (The Most Significant Bit (MSB) of the result)
flag are both very easy to derive and were the only ones included in the prototype.
However, the experience of programming for the CPU showed that it is desireable

Niklas Schelten

11

2 Architecture

Shifter

a1

a0

5
6

2
3
2A
2B

1A
1B

1Y
2Y
3Y
4Y

1A
1B

7

4

11
10

5
6

2
3

4A
4B

3A
3B

2A
2B

1A
1B

U15
74F157
1Y
2Y

9

14
13

1Y
2Y
3Y
4Y

7

4

5
6

2
3

3A
3B

2A
2B

1A
1B

U17
74F157

9

11
10

4A
4B

1Y
2Y
3Y
4Y

7

4

11
10

5
6

2
3

4A
4B

3A
3B

2A
2B

1A
1B

U19
74F157

9

14
13

U20
74F157

12

L4

7

4

11

5
6

2
3

2A
2B

1A
1B

L4

1Y
2Y
3Y
4Y

4
7
9
12

L1

11

5
6

2
3

2A
2B

1A
1B

L1 10

4A
4B

L1

14
L1 13

L4

1Y
2Y
3Y
4Y

9

7

4

11
10

5
6

2
3

4A
4B

3A
3B

2A
2B

1A
1B

L4

shift 1
shift 2
shift 4
L4

11
10
9

4
3
2
1
15
14
13
12

G

A
B
C

D0
D1
D2
D3
D4
D5
D6
D7

U102
74F151

7

Y
Y

5
6

2Y

12

9

7

4

shift3

shift2

shift1

shift0

shift3

shift2

shift1

shift0

shift3

shift2

shift1

shift0

Zu ALU-Ausgangsmul

3Y

U21
74F157

4Y

4Y

3Y

2Y

1Y

12

9

7

4

shift7

shift6

shift5

shift4

shift7

shift6

shift5

shift4

shift7

shift6

shift5

shift4

U22
74F157

1Y

Reverse MUX

2
3

2A
2B

3Y

12

14
13

Shift 4 MUX

4
5
6

3A
3B

4Y

U18
74F157

12

Shift 2 MUX

7

11
10

4A
4B

Shift 1 MUX

9

14
13

U13
74F157

12

U16
74F157
1Y

9

L1 10

4A
4B

14
13

L4

1A
1B

2Y
3Y

14
L1 13

12

L4

4

2
3

2A
2B

12

3A
3B

L4

7

5
6

4Y

3A
3B

L4

L4

9

11
10

3A
3B
L1 13

4A
4B

12

14

L4
U14
74F157
1Y
2Y
3Y
4Y

bus0
bus1
bus2

12

Reverse MUX

a2
3A
3B

1A
1B

11
10

a4
2
3
2A
2B

4A
4B

a5
5
6

14
13

a6
11
10
3A
3B

1

Figure 2.2: 8 bit bidirectional barrel shifter.

ctrlAluSub
reverse
rightNotLeft

4A
4B

ctrlAluSub
reverse
rightNotLeft

A/B

G

15

15

G
1

A/B
bus2
shift 4

14
13

a7

bus2
shift 4
1
A/B
G
15
15
G
1

A/B

15
G
bus1
shift 2

A/B

15
G
1

A/B
bus0
shift 1

a3

Vom Flag-Register
flagCarry

bus1
shift 2
1
A/B
15

G

1

bus0
shift 1
1
A/B
15

G

ctrlAluSub
reverse
rightNotLeft
1
A/B
G
15
15
G
1

A/B
ctrlAluSub
reverse
rightNotLeft

2.2 Modules
to be able to work with more advanced ALU flags when programming more complex functions. Having only Zero and Negative Flags, for example, does not allow
unsigned operations of the full width3 which is especially important with only 8
data bits. It limits unsigned operations to only 0-127 even though the ALU would
be capable of calculations with 0-255.
A lot of modern CPUs feature many different flags with the Intel 64® and IA-32
CPU having about 20 different flags [15, Section 3.4.3]. However, the popular ARM
Architecture has a rather unique but very capable system for conditional execution
which relies on only the four most used ALU flags. The EDiC uses the same flags
and their functions are as follows:
• N The Negative flag indicates that the result is negative and is set if the 8th
bit of the ALU result (MSB) is '1'.
• Z The Zero flag indicates that the result is 0 and is set if all 8 result bits are
0.
• V The Overflow flag indicates that an overflow occurred and is set if the carry
in and carry out of the 8th full-adder are different. This detects arithmetic
overflows for signed two’s-complement calculations.
• C The Carry flag is the carry out bit of the adder for adding and subtracting.
For logical operations (XOR and AND) the carry flag has no meaning and for
shifting operations it equals the last bit that was “carried out” (or is unchanged
if shifting by 0 bits).

2.2.2 Register File
As is typical with CISCs the CPU does not need many general purpose registers
and the register file can be kept simple with only two registers. The register file has
one write port (from the bus) and two read ports of which one reads to the bus and
the other is directly connected to the A input of the ALU. All ports can access both
registers.

2.2.3 Program Counter (PC) & Instruction Register
The PC is a special 16 bit register which is used to store the address for the current
instruction. Usually it is incremented by one for each instruction. However, it is
3

An overflow detection is not possible and with that a greater or less than comparison cannot
be done.

Niklas Schelten

13

2 Architecture
also possible to load the PC from an instruction immediate (see below) or from
the memory (section 2.2.5). The first option is used for branch instruction while
the second option is used for returning from a function, which is explained in more
detail in section 2.2.5.2. The value of the PC is used as address for the instruction
EEPROMs and can also be driven to the memory for storing the return address for
function calls.
Each instruction of the EDiC is stored in a 24 bit register of which 8 bits
are the instruction and 16 bits represent an optional instruction immediate. It
can be used as an address for the memory/PC (16 bit) or as data (8 bit)
driven to the bus. The instruction is directly forwarded to the control logic (section 2.2.4).

2.2.4 Control Logic
The control logic’s job is to decode the current instruction and provide all the control
signals for each cycle for any instruction. What kind of control signals exist in the
EDiC is explained after all the modules are described in section 2.3. For keeping
track which cycle of each instruction is currently executing, a 3 bit synchronous
counter is used. Each control signal could be derived by a logical circuitry with
13 inputs: 8 bits instruction, 4 bits ALU flags and 3 bits cycle counter. However,
designing these logic circuits is a lot of work, takes up a lot of space and cannot be
changed easily later on. Therefore, an EEPROM is used where the 13 bits that define
one cycle of one specific instruction are used as addresses. The control signals then
are the data bits of the word that is stored at the specific address in the EEPROM.
How the EEPROM is programmed with the correct data is explained in depth in
section 3.1.
One special case are the 3 bits ALU opcodes. They are not decoded the usual
way from the instruction but are directly take from the 3 Least Significant Bits
(LSBs) of the instruction. This is done to reduce the storage requirements for the
decoding EEPROMs. For instructions that use the ALU, the 3 LSBs need to be set
accordingly but for all other instructions, the three bits can be used as usual for
decoding the instruction because it does not matter what the combinatorial part of
ALU does.
The first two cycles of each instruction need to be taken in special consideration
because the instruction register is not yet loaded with the next instruction, because
it is still being fetched and decoded. However, the instruction fetch and decode are
always the same for each instruction, which means that all memory locations where

14

2.2 Modules
the cycle counter is equal to 0 or 1 are filled with the control signals for an instruction
fetch and decode.

2.2.5 Memory
The memory module became the most complex module because it includes not only
the main memory of the CPU in form of an asynchronous SRAM but also includes
a lot of addressing logic for the 16 bit addresses.
The addressing logic is required because the EDiC has 16 bit addresses with only an
8 bits data bus. However, the EDiC also features memory mapped I/O and a stack
implementation which further complicate the addressing logic. Both these features
and the addressing logic is described below.

2.2.5.1 Memory Mapped I/O
Input and Output is one of the most important factors of any CPU besides the
computing capabilities which are mostly defined by the ALU. The first prototype
showed that using individual instructions for I/O which directly read from and write
to the bus are limiting the usability quite a lot. A common way to extend the I/O
capabilities is to use so called memory mapped I/O. This works by splitting the
address space between actual memory and I/O devices. Then every I/O operation is
performed as a usual memory access but the memory chip does not receive the access
and the I/O device addressed performs the operation. In the EDiC the memory
address is decoded in such a way, that accesses to addresses 0xfe00 to 0xfeff are
performed by any connected I/O devices. For this to work, the lower 8 address bits,
the bus and memory control signals - i.e. write enable, read enable and I/O chip
enable (active when the upper 8 address bits are 0xff) - are exposed for I/O devices
to connect to.

2.2.5.2 Stack Implementation
A feature that has been thoroughly missing from the prototype CPU is a kind of
stack implementation. The stack is essential to the workings of the very important
programming paradigm functions. When calling functions, the return address is
usually (automatically) stored on the stack where also function local variables can be
stored. This allows functions to be called recursively and also simplifies the written
program code compared to simple branching.

Niklas Schelten

15

2 Architecture
However, a typical stack implementation as in modern CPU architectures like ARM
is rather complex. It requires a Stack Pointer (SP) register which usually is accessible
like any other general purpose register and can be directly used as an address. This
includes using it as operand for arithmetic operations which is not possible when the
bus width is only 8 bits but the SP needs to be 16 bits wide to be used as an address.
Therefore, the EDiC uses an unique approach to the stack:
Similarly to the memory mapped I/O it was decided to implement the SP as an 8
bit register which can be incremented and decremented at function calls and returns,
respectively. Every time a memory access is performed where the upper 8 bits of
the address equal 0xff, a 17th address bit is set and the upper 8 address bits are
replaced by the current value of the SP. For example: The SP is currently 0x21 and
a memory access to the address 0xff42 is performed. Then the actual address at
the memory IC is 0x1_2142.
This allows each function (which has a unique SP value on the current call stack)
to have 256 bytes of function local memory. In the call instruction, the EDiC automatically stores the return address (next PC value) at address 0xffff, which
is 0x1_{sp}ff after translation. To store the whole 16 bit return address, a second memory IC is used in parallel which only needs 256 bytes of storage. In the
hardware build of the EDiC the same SRAM IC as for the main memory is used
because it is cheaply available and the built is simplified by not using more different components. The call and return instructions are further described in section 2.4.
Usually, the stack is also used to store parameters for a function call. In the EDiC,
this can be achieved by providing a special store and load instruction which access
the stack memory with an increment SP. This way it is possible to store parameter before calling a function and it is also possible to retrieve modified values
after the call4 . The calling convention for the EDiC is further described in section 3.2.1.
2.2.5.3 Addressing Logic
With increasing the address width to 16 bit and also adding more functionality to the
memory access, the addressing logic has become more complex. There are two main
sources for memory addresses: The new 16 bit Memory Address Register (MAR)
4

This is important when a function takes memory pointers as parameters and modifies the
memory content. For example a string parsing function could take a pointer to the start of the string,
parse some characters as a number, return its number representation and modify the parameter
such that it points to where the parsing stopped.

16

2.2 Modules
which can be written to from the bus and secondly the 16 bit instruction immediate.
As the bus is only 8 bits wide, there is a special instruction to write to the upper
8 bits of the MAR and the lower bits are written in the memory access instruction.
This can be used when a memory address is stored in registers and is needed when
looping through values in the memory like arrays. When accessing addresses known
at compile time, the 16 bit instruction immediate can be directly used as an address,
preserving the MAR. These two sources of addresses are then decoded to either select
the stack (upper 8 bits equal 0xff), memory mapped I/O (0xfe) or regular memory
access. The chip enable of the main memory is only asserted when performing stack
and regular memory accesses while the I/O chip enable is only asserted when the
upper 8 bits are 0xfe. Additionally, the 17th address bit is asserted when stack
access is performed and the upper 8 bits of the address are replaced with the SP in
this case.

2.2.6 Input & Output
The EDiC can interface with different I/O devices connected to it via the memory
mapped I/O. For evaluation and debugging, the EDiC includes one I/O device at
address 0x00 which can be read from and written to. The value to be read can be
selected by the user with two hexadecimal 8 bit switch and the values written to
the address 0x00 are displayed with a 2 digit display. This allows simple programs
to run independently of external I/O devices.

2.2.7 Clock, Reset & Debugging
An important feature when developing a CPU is debugging capabilities. The initial
prototype could at least step the clock cycle by cycle. However, as programs get
more complex this feature quickly becomes less useful as each instruction is made
of several cycles and when a problem occurs after several hundred instructions it is
infeasible to step through all cycles. Additionally, the usual application developer
does not want to step through each cycle but rather step through each instruction,
assuming that the instruction set works as intended. Another important debugging
feature is the use of breakpoints where the CPU halts execution when the PC reaches
a specific address.
In the EDiC halting was not realized by stopping the clock completely but rather by
inhibiting the instruction step counter increment. This has the advantage that the
clock is not abruptly pulled to 0 or 1 and, therefore, no spikes on the clock line can

Niklas Schelten

17

2 Architecture
occur. To implement a cycle by cycle stepping mode, the halt signal is de-asserted
for only one clock cycle, which in turn increments the step counter only once. To
step whole instructions, the halt signal is de-asserted until the instruction is finished
(marked by a control signal that is asserted at the end of each instruction from the
control logic). In breakpoint mode, the halt signal is controlled from a comparator
that compares the PC and a 16 bit user input, asserting the halt signal when those
two equal. As soon as the CPU halts, the user can then switch to stepping mode and
debug the specific instruction of the program. As soon as the CPU halts, the user
can then switch to stepping mode and debug the specific instruction of the program.
The user can freely switch between these modes with switches and buttons provided
on the lower side of the PCB in figure 1.1.

2.3 Control Signals
The EDiC has 24 control signals which define what the current cycle
does:
• aluYNWE - ALU output register write enable (active low): Connects to the
clock enable input of the ALU output register.
• aluNOE - ALU output enable (active low): Enables the tri-state buffer to drive
the bus with the value of the ALU output register.
• reg0NWE - Register 0 write enable (active low): Connects to the clock enable
input of the register 0.
• reg1NWE - Register 1 write enable (active low): Connects to the clock enable
input of the register 1.
• regAluSel - Register Select for the ALU A input: When 0, sets register 0 as
A input to the ALU, otherwise, register 1.
• reg0BusNOE - Register 0 bus output enable (active low): Drives the bus with
the value of register 0.
• reg1BusNOE - Register 1 bus output enable (active low): Drives the bus with
the value of register 1.
• memPCFromImm - load data for PC from instruction immediate: Selects the
load input of the PC to be from the instruction immediate instead of from the
memory.

18

2.3 Control Signals
• memPCNEn - PC enable (active low): enables the PC to load data or increment
by one depending on the next control signal.
• memPCLoadN - PC load and not increment (active low): When 0 load the PC
with the data specified by memPCFromImm, otherwise, increment the PC by one.
• memPCToRamN - PC output enable (active low): Drives the bus and ram2data
with the value of the PC.
• memSPNEn - SP enable (active low): enable the SP to be incremented or decremented depending on the next control signal.
• memSPUp - SP increment not decrement: When 1, increment the SP, otherwise,
decrement.
• memInstrNWE - Instruction write enable (active low): Connects to the clock
enable input of the instruction register.
• memInstrNOE - Instruction output enable (active low): Drives the bus with the
lower 8 bits of the instruction immediate.
• memMar0NWE - MAR bits 7..0 write enable (active low): Connects to the clock
enable input of the lower 8 bits of the MAR.
• memMar1NWE - MAR bits 15..8 write enable (active low): Connects to the clock
enable input of the upper 8 bits of the MAR.
• memInstrImmToRamAddr - Random-Access Memory (RAM) address from instruction immediate and not MAR: When 1, use the instruction immediate as
address for the memory, otherwise, use the MAR content.
• memRamNWE - Memory write enable (active low): Connects to the write enable
input of the SRAM and I/O.
• memRamNOE - Memory output enable (active low): Drives the bus with the value
of the SRAM or I/O depending on the memory address (section 2.2.5).
• instrFinishedN - Instruction finished (active low): Is asserted at the last
active cycle of the instruction to reset the step counter to 05 .
• busFFNOE6 - Drive 0xff to the bus (active low): Connects to the output enable
input of the constant 0xff driver.

5

the instruction finished signal is also used for the debugger to detect the end of an instruction
and halt when stepping through instructions and not single cycles.
6
Was added in the component verification and is explained in section 6.2.3.

Niklas Schelten

19

2 Architecture

2.4 Final Instruction Set
This section describes all available instructions, what they do and which instruction
cycle performs which steps of the instruction. Each instruction starts with the same
two cycles for instruction fetching. The parameters of each instruction and how the
instructions are programmed is shown in section 3.2.2.

2.4.1 ALU operations
The EDiC supports a wide variety of instructions that perform ALU operations.
All these operations take two arguments which are used for one of the possible operations shown in table 2.1. Each ALU operation modifies the status
flags.
• Register x Register: Takes two registers as parameter and the result is stored
in the first parameter.
Cycles:
1. Both register to ALU A and B input, write enable of ALU result register.
2. Write content of ALU result register into first parameter register.
• Register x Register (no write back): Takes two registers as parameter and the
result is only calculated for the status flags.
Cycles:
1. Both register to ALU A and B input, write enable of ALU result register.
• Register x Memory (from Register): Takes one register as ALU A input and a
second register which is used as a memory address for the ALU B input. The
result is stored in the first register.
Cycles:
1. Second register is stored in the lower 8 bits of the MAR7 .
2. Address decoding.
3. First register and memory content as A and B inputs, write enable of the
result register.
4. Write content of ALU result register into first parameter register.
7

20

The upper 8 bits of the MAR should be set beforehand

2.4 Final Instruction Set
• Register x Memory (from immediate): Takes one register as ALU A input and
a 16 bit value as immediate which is used as a memory address for the ALU
B input. The result is stored in the first register.
Cycles:
1. Address decoding.
2. First register and memory content as A and B inputs, write enable of the
result register.
3. Write content of ALU result register into first parameter register.
• Register x Memory (from immediate, no write back): Takes one register as
ALU A input and a 16 bit value as immediate which is used as a memory
address for the ALU B input. The result is only calculated for the status flags.
Cycles:
1. Address decoding.
2. First register and memory content as A and B inputs, write enable of the
result register.
• Register x Immediate: Takes one register as ALU A input and an 8 bit value
as immediate for the ALU B input. The result is stored in the first register.
Cycles:
1. Register and immediate value as A and B inputs and write enable of the
result register.
2. Write content of ALU result register into first parameter register.
• Register x Immediate (no write back): Takes one register as ALU A input and
an 8 bit value as immediate for the ALU B input. The result is only calculated
for the status flags.
Cycles:
1. Register and immediate value as A and B inputs and write enable of the
result register.

2.4.2 Memory operations
Some ALU operations also include reading values from memory. However, the EDiC
features a lot more memory operations which are detailed below. As all memory

Niklas Schelten

21

2 Architecture
operations may perform memory mapped I/O operations, special care must be taken
to allow asynchronous I/O devices to function as well. This means that for each
memory access, the address setup and hold must be an individual cycle, resulting
in a 3 cycle memory access.
• Load from register address: Takes the second register parameter as the lower 8
bits of the memory address and writes the memory content to the first register.
Cycles:
1. Second register to lower MAR.
2. Memory address setup.
3. Memory read access and write back to first register.
4. Memory address hold.
• Load from immediate address: Takes a 16 bit immediate as the memory address
and writes the memory content to the register.
Cycles:
1. Memory address setup.
2. Memory read access and write back to first register.
3. Memory address hold.
• Load from immediate address with incremented SP: Takes a 16 bit immediate
as the memory address and writes the memory content to the register. However,
before the memory access, the SP is incremented and after the access, the SP
is decremented again. This is used to access parameters for subfunctions.
Cycles:
1. Increment Stack Pointer.
2. Memory address setup.
3. Memory read access and write back to first register.
4. Memory address hold.
5. Decrement Stack Pointer.
• Store to register address: Takes the second register parameter as the lower 8
bits of the memory address and writes the content of the first register to the
memory.
Cycles:

22

2.4 Final Instruction Set
1. Second register to lower MAR.
2. Memory address and data setup.
3. Memory write access.
4. Memory address and data hold.
• Store to immediate address: Takes a 16 bit immediate as the memory address
and writes the register content to memory.
Cycles:
1. Memory address and data setup.
2. Memory write access.
3. Memory address and data hold.
• Store to immediate address with incremented SP: Takes a 16 bit immediate
as the memory address and writes the register content to memory. However,
before the memory access, the SP is incremented and after the access, the SP
is decremented again. This is used to access parameters for subfunctions.
Cycles:
1. Increment Stack Pointer.
2. Memory address and data setup.
3. Memory write access.
4. Memory address and data hold.
5. Decrement Stack Pointer.
• Set upper 8 bits of MAR from register: Sets the upper MAR register to the
content of the register.
Cycles:
1. Register output enable and upper MAR write enable.
• Set upper 8 bits of MAR from immediate: Sets the upper MAR register to the
8 bit immediate value.
Cycles:
1. Immediate output enable and upper MAR write enable.

Niklas Schelten

23

2 Architecture

2.4.3 Miscellaneous operations
There are some more operations that are neither ALU nor memory operations like
move and branch instructions.
• Move between register: Set the first register to the value of the second.
Cycles:
1. Second register output enable and first register write enable.
• Move immediate to register: Set the register to the value of the immediate.
Cycles:
1. Immediate output enable and first register write enable.
• Conditionally set PC from immediate: This is the only conditional operation
available. Depending on the current status register the following cycles are
either executed or No Operations (NOPs) are executed.
Cycles:
1. PC write enable from immediate.
• Function Call: Takes a 16 bit address which the PC is set to. The SP is
incremented and the return address is stored on the stack.
Cycles:
1. Increment SP and write 0xffff into the MAR.
2. Memory address and data (PC) setup.
3. Memory write access.
4. Memory address and data hold.
5. Load PC from instruction immediate.
• Function Return: Decrements the SP and the PC is loaded from the return
address which is read from the memory.
Cycles:
1. Write 0xffff into the MAR.
2. Memory address setup.
3. Memory read access and PC write enable.
4. Memory address hold.
5. Decrement SP.

24

3 Software Development
Environment
When just providing the hardware, the CPU can hardly be used. It is possible to
write programs by hand by writing single bytes to the EEPROMs that hold the program. However, it is quite infeasible to write complex programs this way. Even more
extreme is content of the EEPROMs holding the micro code, i.e. that decode the
instruction depending on the instruction cycle and ALU flags.
Therefore, the EDiC comes with two main software utilities that form the Software
Development Environment.

3.1 Microcode Generation
The goal is to define all the available instructions and what they perform in which
instruction step and then have a program automatically generate the bit-files for the
EEPROM. This approach allows easy modifications to the existing microcode if a
bug was found or a new instruction should be added. The file format which defines
the microcode has to be human and machine readable as it should be easily edited
by hand and also be read by the tool that generates the bit-files. A very common
file format for tasks like this is JavaScript Object Notation (JSON) [16] which is
widely used in the computer industry. Besides basic types as strings and numbers,
it allows arrays with square brackets ([]) and objects with curly braces ({}). Each
object contains key value pairs and everything can be nested as desired. For the
EDiC microcode generation CoffeeScript-Object-Notation (CSON) was used which
is very similar to JSON but is slightly easier to write by hand because its syntax is
changed a bit:
• It allows comments which is extensively used to ease the understanding of
individual instruction steps
• Braces and commas are not required

25

3 Software Development Environment
interface IMicrocodeFile {
signals: [
{
name: string;
noOp: 0 | 1;
}
];

1
2
3
4
5
6
7
8

instructionFetch: [
{
[signalName: string]: 0 | 1;
}
];

9
10
11
12
13
14

instructions: [
{
op: string;
cycles: [
{
[signalName: string]: 0 | 1 | 'r' | 's' | '!r' | '!s';
}
];
}
];

15
16
17
18
19
20
21
22
23
24

};

25

Code Example 3.1: Schema of the Microcode Definition CSON-File [3] as a
TypeScript [19] Type definition.
• Keys do not require string quotation marks
The schema for the file describing the microcode is shown in code example 3.1.
Examples for the fields follow:

Signals The signals array consists of objects that define the available control signals
and the default value of the control signal. Code Example 3.2a defines the not write
enable signal for register 0 control signal and defines the default state as high. This
means, when this control signal is not specified in an instruction it will stay high
and, therefore, register 0 will not be written.

InstructionFetch This array defines the steps that are performed at the beginning of each instruction to fetch the new instruction and decode it. Each object

26

3.1 Microcode Generation

1
2
3
4
5
1

{
name: 'reg0NWE'
noOp: 1

2
3
4

6

}

7
8
9

instructionFetch: [
{ # write instruction
memInstrNWE: 0
}
{ # increment PC
memPCNEn: 0
memPCLoadN: 1
}
]

(a) Register 0 write enable control signal. (b) Instruction fetch and decode cycles.

Code Example 3.2: Example definitions of one control signal and the instruction fetch cycles for the microcode generation.
represents one step and consists of key value pairs that define one control signal.
In code example 3.2b the first instruction cycle specifies only the instruction not
write enable to be low and with this write the instruction into the instruction register.
Secondly, the PC is incremented by setting PC not enable to low and PC not load
to high.
Instructions The instructions are an array of all available instructions. Each instruction is defined as an op code, which is the 8 bit instruction in binary format.
However, if it was only possible to define the 8 bit as 0s and 1s, instructions which
only differ in the register used would need to be specified separately which is very
error prone. Therefore, it is allowed to specify the bit that specifies if register 0
or 1 is used to be set to 'r' or 's' and then multiple instructions are generated.
The cycles array defines the steps each instruction does in the same way as the
instructionFetch array does. However, as the value of individual control signals
may depend up on which register is specified in the op code, it is also possible to
specify 'r', '!r', 's' or '!s'.
Code Example 3.3a defines the move immediate to register instruction for both
register at the same time. The instruction immediate not output enable is low and
either register 0 or register 1 is written to. This definition would be equal to code
example 3.3b.
This example is quite simple, however, instructions with two registers as arguments
would result in four times the same definition and duplication can always result
in inconsistencies. The same idea is also used for the ALU operations. The ALU
operation control signals are not generated by the microcode but are rather the

Niklas Schelten

27

3 Software Development Environment

1

[
{

2

op: '11111000' # r0 = imm
cycles: [
{ # imm to bus to r0
reg0NWE: 0
reg1NWE: 1
memInstrNOE: 0
}
]

3
4
5
6
7
8
9
10

}
{

11
12

op: '11111001' # r1 = imm
cycles: [
{ # imm to bus to r1
reg0NWE: 1
reg1NWE: 0
memInstrNOE: 0
}
]

13

{

1

14

op: '1111100r' # r = imm
cycles: [
{ # imm to bus to r
reg0NWE: 'r'
reg1NWE: '!r'
memInstrNOE: 0
}
]

2
3
4
5
6
7
8
9

15
16
17
18
19
20

}

21
22

]

}

10

(b) Equivalent definition of both separate in(a) Definition using ‘r’ in the opcode.
structions.

Code Example 3.3: Definition of the move immediate to register instruction
for the microcode generation.
three least significant bits of the instruction. Therefore, all instructions using the
ALU can have the exact same control signals stored in the microcode EEPROM. To
avoid 8 definitions of the same instructions, the op code can contain 'alu' and all 8
instructions are generated. Code example 3.4 for example defines the alu operation
with two registers and defines all 32 instructions with the op codes '00000000' to
'00011111'.
There is one final specialty built into the Microcode Generator: The EDiC has a
branch instruction which is either executed or treated as a no-operation depending
on the current state of the ALU flags. For all other instructions, the flags are ignored
and the instructions are always executed. For this special instruction, the last four
bits replaced with flag define at which state of the ALU flags, the branch should be
executed. The possible conditions are heavily inspired by the conditional execution
of ARM CPUs[8] as the ALU flag architecture is very similar. The possible values
for the flag field and their meanings are listed in table 3.1. Especially for a CPU

28

3.2 Assembler

1

{
op: '000rsalu' # r = r x s (alu)
cycles: [
{ # r x s into alu
aluYNWE: 0
reg0BusNOE: 's'
reg1BusNOE: '!s'
regAluSel: 'r'
}
{ # alu into r
aluNOE: 0
reg0NWE: 'r'
reg1NWE: '!r'
}
]

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

}
Code Example 3.4: Definition of the alu operation with two register arguments for the microcode generation.

1

{
op: '1010flag' # pc := imm
cycles: [
{ # imm to pc
memPCNEn: 0
memPCLoadN: 0
memPCFromImm: 1
}
]

2
3
4
5
6
7
8
9
10

}
Code Example 3.5: Definition of the branch instructions.

with only 8 bits it is important to support unsigned and signed operations and with
a complex microcode it is no problem to support all the different branch instructions and facilitate the application design. Code example 3.5 defines the branch
instructions.

3.2 Assembler
The second software that is similarly important is the assembler. An assembler translates human readable instructions into the machine code, i.e. the bits that are stored
in the instruction EEPROMs. For the EDiC each instruction is 24 bits wide, with

Niklas Schelten

29

3 Software Development Environment

Table 3.1: All available branch instructions with their op-code and microcode
translation based on the ALU flags explained in section 2.2.1.
flag (OP-Code)

Assembler Instruction

ALU flags

Interpretation

0000

jmp/bal/b

Any

Always

0001

beq

Z==1

Equal

0010

bne

Z==0

Not Equal

0011

bcs/bhs

C==1

Unsigned ⩾

0100

bcc/blo

C==0

Unsigned <

0101

bmi

N==1

Negative

0110

bpl

N==0

Positive or Zero

0111

bvs

V==1

Overflow

1000

bvc

V==0

No overflow

1001

bhi

C==1 and Z==0

Unsigned >

1010

bls

C==0 or Z==1

Unsigned ⩽

1011

bge

N==V

Signed ⩾

1100

blt

N!=V

Signed <

1101

bgt

Z==0 and N==V

Signed >

1110

ble

Z==0 or N!=V

Signed ⩽

1111

-

Any

Never (Not used)

8 bits instruction op code and 8 or 16 bits immediate value. Even though assemblers usually only translate instructions one for one, they can have quite advanced
features. With an assembler, the programmer is no longer required to know the specific op codes for all instructions and set individual bits of the instructions which is
very error prone. The assembler for the EDiC, therefore, allows easier programming
with a simple text-based assembly syntax similar to the well-known ARM syntax.

Code examples 3.6 and 3.7 show the translation that the assembler does where
code example 3.6 shows the assembler program that is written by the programmer
and code example 3.7 summarizes what values are stored in the program EEPROM.
The full assembler code used in the demonstration in figure 1.1 is attached in appendix A.

30

3.2 Assembler

1
2

PRNG_SEED = 0x0000
SIMPLE_IO = 0xfe00

3
4
5
6
7
8
9
10
11
12
13
14
15

prng:
ldr r0, [PRNG_SEED]
subs r0, 0
beq prngDoEor
lsl r0, 1
beq prngNoEor
bcc prngNoEor
prngDoEor:
xor r0, 0x1d
prngNoEor:
str r0, [PRNG_SEED]
ret

16
17
18
19
20
21
22
23

start:
mov r0, 0
str r0, [PRNG_SEED]
prng_loop:
call prng
str r0, [SIMPLE_IO]
b prng_loop
Code Example 3.6: Pseudo Random Number Generator (PRNG) written in
the EDiC Assembler.

3.2.1 Calling conventions
Even though calling conventions are strictly speaking not a feature of the assembler,
it is an important factor to keep in mind with functional programming. Calling
conventions are a set of rules which caller (the instructions calling a subroutine) and
callee (the subroutine that is called) should usually follow.

Parameters Usually the first parameters from the caller to the callee are passed in
registers, which avoids long memory operations for storing and loading the parameters. In the EDiC memory operations cannot stall and are, therefore, not slower
than register operation and the EDiC has only 2 registers. Therefore, only the very
first argument is passed in r0 and all further arguments are passed in the memory.
The parameters are stored on the stack of the callee starting at stack address 0x00
(0xff00 as memory address).

Niklas Schelten

31

3 Software Development Environment
0x0000 - op: 10100000, imm: 0x000a - b 0x0a
0x0001 - op: 11110000, imm: 0x0000 - ldr r0, [0x00]
0x0002 - op: 10010001, imm: 0x0000 - subs r0, 0x00
0x0003 - op: 10100001, imm: 0x0007 - beq 0x07
0x0004 - op: 10000111, imm: 0x0001 - lsl r0, 0x01
0x0005 - op: 10100001, imm: 0x0008 - beq 0x08
0x0006 - op: 10100100, imm: 0x0008 - bcc 0x08
0x0007 - op: 10000100, imm: 0x001d - xor r0, 0x1d
0x0008 - op: 11110010, imm: 0x0000 - str r0, [0x00]
0x0009 - op: 10110001, imm: ------ - ret
0x000a - op: 11111000, imm: 0x0000 - mov r0, 0
0x000b - op: 11110010, imm: 0x0000 - str r0, [0x00]
0x000c - op: 10110000, imm: 0x0001 - call 0x01
0x000d - op: 11110010, imm: 0xfe00 - str r0, [0xfe00]
0x000e - op: 10100000, imm: 0x000c - b 0x0c

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

Code Example 3.7: The output of the PRNG of code example 3.6. The first 16
bits are the memory address, then 8 bits for the instruction op-code and 16 bits for the instruction immediate
and for reference the original instruction with variables
replaced.
Return value The return value is to be placed in r0. If a return value larger than
8 bit (or multiple 8 bit values) are to be returned, the caller may pass a pointer
to a memory location as a parameter and the callee works on the memory content
pointed to.

Preservation The register r1 can to be used as a function local variable and,
therefore, has to be preserved by any callee. This is usually done by storing the
content on the stack at the beginning of the function and restoring them from the
stack at the end of the function.

3.2.2 Available Instructions
This section summarizes all available instructions and which parameters they take.
All instructions start with the operation and then up two parameters which are
separated by a comma.
There are four different parameter types. It can either be a register specified as r0
or r1. The register value can also be passed as the address to a memory operation
with [r0].

32

3.2 Assembler
Immediate values can also be specified as value or as address with brackets around
the immediate value. However, the syntax for immediate values is more complex,
as the assembler can parse decimal (positive and negative) as well as hexadecimal
numbers. Additionally, variables can be used which are further explained in section 3.2.3.
When specifying a value, the immediate can range between -127 and 255 (two’s
complement and unsigned) and when used as an address it can range between 0 and
0xfffe (65534). The upper limit is not 0xffff because that address is reserved for the
return address and should not be overwritten.

3.2.2.1 ALU Instructions
The following ALU instructions are available:
• add

• and

• xor

• lsr

• sub

• eor

• xnor

• lsl

ALU instructions always take two parameters. The first parameter is the left hand
side operand and the register where the result is stored in and the second parameter
is the right hand side operand.
• Two registers
sub r0, r1 does: r0 := r0 − r1
• One register and one register as memory address
lsr r1, [r0] does: r1 := r1 ≫ mem[r0 ]
• One register and an immediate value
xor r0, 0x0f does: r0 := r0 ⊻ 15
• One register and an immediate value as memory address
add r1, [0x0542] does: r1 := r1 + mem[1346]
All of the ALU instructions can have an ‘s’ as suﬀix which has the effect that the
result of the operation is not written to the first operand. This is useful when a
calculation is only performed to update the ALU flags but the register value should
be preserved. This results in a special ALU instruction: cmp which is an alias to
subs which is typically used to compare to values and perform a branch instruction
based on the result.

Niklas Schelten

33

3 Software Development Environment
cmp r0, 10 // equal to subs r0, 10
blt 0x42
compares the r0 register with the value 10 and if r0 < 10 branches to instruction at
address 66 and preserves the content of r0.

3.2.2.2 Memory Instructions
The following memory instructions are supported:
• str

• sts

• stf

• ldr

• lds

• ldf

• sma

The two common instructions are str and ldr which are store and load operations.
These two instructions take two parameters: The first is the register used in the
store or load operation and the second is the memory address. They either take a 16
bit immediate address which is used as the full address for the access or a register as
address. As the registers are only 8 bits, the register value is only used for the lower
8 bits of the address and the upper 8 bits are the value of the MAR. The upper 8
bits of the MAR can be set with the sma instruction which takes either a register or
an 8 bit immediate value.
The lds and sts instructions are used for accessing the stack. They only take
immediate addresses and the assembler makes sure that the upper 8 bits of the
address are 0xff to always access the stack.
The ldf and stf functions work very similar in only accessing the stack. However, before the memory access, the SP is incremented and after the access, it
is restored. This way, it is possible to access parameters of a function that is
called.
Some examples:

34

3.2 Assembler
ldr r0, [0xabba]
str r1, [0xc0de]

Loads the value from address 0xabba into r0
Stores the value in r1 to address 0xc0de

sma 0xca
mov r0, 0xfe
ldr r0, [r0]

Loads the value from address 0xcafe into r0

Loads the value fromm address 0xff42 which is translated into 0x{sp}42 into r1
Stores the value in r0 to address 0xffab with incremented SP which is translated into 0x{sp+1}ab

lds r1, [0x42]
stf r0, [0xab]

3.2.2.3 Miscellaneous Instructions
There are four more instructions that are essential:
• mov

• b

• call

• ret

The mov instruction either takes two registers or one register and an 8 bit immediate
value as parameters. When specifying two registers, the content of the second register
is copied to the first register. Otherwise, the immediate value is stored in the register.
The branch (b) instruction takes a 16 bit immediate value which is used as the new
PC content. It is the only conditional instruction that is available in the EDiC
instruction set. The second column of table 3.1 lists all the possible suﬀixes for
conditional branches and their meanings. If the condition is met, the branch is
executed, otherwise the instruction has no effect.
The call instruction also takes a 16 bit immediate address which is the destination
address for the call. In contrast to the branch instruction, the call is not conditional
(i.e. it is always executed) and has the side effect of incrementing the SP and storing
the current PC on the stack at address 0x{sp}ff.
The ret instruction is used at the end of a function without any parameters
to restore the PC from the stack at address 0x{sp}ff and decrement the SP
again.
Some examples:

Niklas Schelten

35

3 Software Development Environment
mov r0, 0xda
mov r1, r0

Sets r0 to 0xda
Copies the value of r0 to r1

cmp r0, 10
blt 0x42

Branches to address (sets the PC to) 0x42 if the value
of r0 is smaller than 10

call 0x100
ret

Calls a function at address 0x100
Returns from a function to the caller

3.2.3 Constants
One main improvement that an assembler allows over manually setting the instruction bits is the use of constants in the code. They can be declared to represent a value
and then used similarly to variables of higher level languages instead of hard coded
numbers. The EDiC assembler supports three kinds of constants: Value constants,
labels and string constants.

3.2.3.1 Value constants
Value constants are the easiest kind of constants available. The first two lines of
code examples 3.6 and 3.8 both declare a value constant that is used exactly like
in higher level languages. In each instruction, which takes an immediate value, the
immediate value can be specified with the name of the constant and the value of the
constant is then used instead. In code example 3.8 line 5 (ldr r0, [PRNG_SEED])
is assembled into the same instruction as ldr r0, [0x00]. Constant declarations
have the format <name> = <value>.
These value constants can be used to make the code easier to understand. For
example str r0, [SIMPLE_IO] makes it clearer that the value of r0 is not stored in
some memory location but rather send to some I/O device (in this case the internal
I/O register from section 2.2.6). It also prevents errors where a typo in an address
causes unintended behavior of the code.

3.2.3.2 Labels
Instruction labels are often used in assemblers and are very important. They are
declared by specifying a label name followed by a colon and hold the address of
the next instruction. Then, they can be used as immediate values for branch and
call instructions to jump to the instruction followed by the label declaration. As

36

3.2 Assembler

1
2

PRNG_SEED = 0x0000
SIMPLE_IO = 0xfe00
prng:
ldr r0, [PRNG_SEED]
subs r0, 0
beq prngDoEor
lsl r0, 1
beq prngNoEor
bcc prngNoEor
prngDoEor:
xor r0, 0x1d
prngNoEor:
str r0, [PRNG_SEED]
ret

// no instruction
// no instruction
b 0x0a // inserted by assembler
// no instruction
ldr r0, [0x00]
subs r0, 0
beq 0x07
lsl r0, 1
beq 0x08
bcc 0x08
// no instruction
xor r0, 0x1d
// no instruction
str r0, [0x00]
ret

start:
mov r0, 0
str r0, [PRNG_SEED]
prng_loop:
call prng
str r0, [SIMPLE_IO]
b prng_loop

// no instruction
mov r0, 0
str r0, [0x00]
// no instruction
call 0x01
str r0, [0xfe00]
b 0x0c

3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

Code Example 3.8: The PRNG of code example 3.6 with the constants and
labels resolved.
seen in code example 3.8 the line 21 (call prng) is assembled into the instruction
call 0x01 which is the location of the instruction after the declarations of the prng
label (ldr r0, [PRNG_SEED]).
The load instruction from line 5 is actually the first instruction of the PRNG algorithm, however, it is not assembled as the first instruction. This is due to a special
label being declared in the code at line 17. When the start label is declared, then a
new instruction is inserted at the beginning which unconditionally branches to the
instruction after the start label. This can be seen in code example 3.7 where the
first instruction is a b 0x0a because the first instruction after the start label got
assembled to the address 0x0a. The use of the start label comes especially clear in
the section 3.2.4.
3.2.3.3 String constants
The third constant is rather advanced and uses very EDiC specific features. It allows
the definition of character strings with a maximum length of 255 chars which can

Niklas Schelten

37

3 Software Development Environment
include "prng.s"
include "uart_16c550.s"
0x20.LOST_STRING = "You lost!!! Score: "
lost:
// [...]
// output the lost string
mov r0, LOST_STRING
call outputString
// output the score
ldr r0, [SNAKE_LENGTH]
call outputDecimal
// [...]

1
2
3
4
5
6
7
8
9
10
11
12
13

// r0: address of string
outputString:
str r1, [0xfffe]
sts r0, [0x00]
mov r1, 0
outputStringLoop:
lds r0, [0x00]
sma r0
ldr r0, [r1]
cmp r0, 0
beq outputStringEnd
call uart_write
add r1, 1
cmp r1, 255
bne outputStringLoop
outputStringEnd:
ldr r1, [0xfffe]
ret

14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31

Code Example 3.9: Excerpts of the Snake assembler program used in the
demo in figure 1.1.
later be used. Differently to the value constants of section 3.2.3.1 strings cannot
be used as parameters to instructions directly, because a string is a rather complex
data structured in the context of assemblers. In the EDiC assembler a string can
be defined as shown in code example 3.9 line 4 with the syntax <address>.<name>
= "<value>". In the example a string constant with the name “LOST_STRING”
is defined to have the content “You lost!!! Score: ” at the address 0x20. The EDiC
assembler treats a string as an NULL-terminated array of characters, meaning that
the characters are stored consecutively in memory and after the last character a
NULL-byte is stored to mark the end of the string. The address of a string constant

38

3.2 Assembler
mov r0, 0x59 // 'Y'
str r0, [0x2000]
mov r0, 0x6f // 'o'
str r0, [0x2001]
mov r0, 0x75 // 'u'
str r0, [0x2002]
mov r0, 0x20 // ' '
str r0, [0x2003]
mov r0, 0x6c // 'l'
str r0, [0x2004]
mov r0, 0x6f // 'o'
str r0, [0x2005]
mov r0, 0x73 // 's'
str r0, [0x2006]
mov r0, 0x74 // 't'
str r0, [0x2007]
mov r0, 0x21 // '!'
str r0, [0x2008]
mov r0, 0x21 // '!'
str r0, [0x2009]
mov r0, 0x21 // '!'

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41

str r0, [0x200a]
mov r0, 0x20 // ' '
str r0, [0x200b]
mov r0, 0x53 // 'S'
str r0, [0x200c]
mov r0, 0x63 // 'c'
str r0, [0x200d]
mov r0, 0x6f // 'o'
str r0, [0x200e]
mov r0, 0x72 // 'r'
str r0, [0x200f]
mov r0, 0x65 // 'e'
str r0, [0x2010]
mov r0, 0x3a // ':'
str r0, [0x2011]
mov r0, 0x20 // ' '
str r0, [0x2012]
mov r0, 0x0 // NULL-byte
str r0, [0x2013]
mov r0, 0 // restore r0

Code Example 3.10: The instructions resulting from the string definition of
code example 3.9 line 4.
actually defines the upper 8 bits of the address where the string is stored and is
also the value of the constant itself. This means that the string in the example is
actually stored at addresses 0x2000 to 0x2013 (18 characters plus 1 NULL-byte) and
mov r0, LOST_STRING in line 9 is equivalent to mov r0, 0x20. As the assembler
has no direct control over the memory contents as for example the ARM assembler,
each string declarations results in two instructions per character that are inserted
at the start of the program1 as shown in code example 3.10.
Code example 3.9 lines 15 to 31 show a function that gets the upper 8 bits of the
string address as a parameter in r0. It outputs the characters one by one in a loop
until the NULL-byte is reached. To retrieve each character, firstly the sma instruction
is called with the MSBs of the address and then the ldr instruction with the loop
register r1 as an address argument is called. The character (in r0) is then passed as
an argument to the uart_write function.

1

Before the b start instruction that is inserted when a start label exists.

Niklas Schelten

39

3 Software Development Environment

3.2.4 File imports
An important factor of software development is reusability. This also holds for assembler development and is the reason why the EDiC assembler supports including
other assembler files. This can for example be used to write a library utility and
then importing its functions for multiple projects. This way, a bug fix in the utility
library will be fixed across all projects at the same time.
As can be seen in code example 3.9 lines 1 and 2, the EDiC assembler supports
the include keyword followed by a relative or absolute filename in double quotes.
Before assembling a file, all the include statements are replaced with the content
of the file specified. All the constants and labels are used as is with some exceptions:
• The start label of all included files are discarded and the main file is required to
provide a start label. Otherwise, the starting point is ambiguous and probably
not where the programmer expects it.
• Constants from included files can be overwritten in the main file. This can be
useful when value constants hold memory locations of global variables that
need to be repositioned in the main file. This also shows why it is important
to use value constants for memory locations of global variables.

3.2.5 Syntax Definition for VS Code
Syntax Highlighting has become a very important factor for software development
as Integrated Development Environments (IDEs) grow more capable. The highlighting is usually done by firstly, parsing the syntax and associating parts of the text
file with specific categories and, secondly, assigning styles like font color to these
categories. This way, a programmer can select a global color scheme which will
define colors for different categories for all programming languages. When applied
correctly, code in different languages becomes easier to recognize because variables
are always colored the same way, no matter the language. The syntax parser, however, needs to be selected correctly for each file type and categorize the file content
correctly.
Even though the EDiC syntax is similar to the ARM syntax, it is not syntactically
identical which makes syntax highlighting in editors diﬀicult. As can be seen in
code example 3.9 line 3, the ARM syntax definition used for the highlighting in
this document is not perfect (The leading 0 is red and the string is not colored
correctly).

40

3.2 Assembler

Figure 3.1: The syntax highlighting with the EDiC Visual Studio Code Extension and the Atom One Light Theme [1].
As Visual Studio Code [20] is one of the leading extensible code editors, an extension
for EDiC assembler has been developed and published [25]. The code of the code
example 3.9 is shown again in figure 3.1 as it is highlighting using the developed
extension. The extension itself mainly consists of a TextMate language definition
[18] and configuration files to work correctly with Visual Studio Code. TextMate is
a tokenization engine which works with a structured collection of regular expressions
as language definitions.

Niklas Schelten

41

4 FPGA Model
The goal of the FPGA model is to proof the general workings of the CPU architecture
before finalizing the hardware layout and PCB design. With the design running on
an actual FPGA it is also possible to debug and test extension cards without the
actual hardware of the EDiC.

4.1 FPGA Background
An FPGA can be seen as an intermediary between Application-Specific Integrated
Circuits (ASICs) and general purpose CPUs. It allows for a lot more design flexibility
in contrast to ASICs by being reprogrammable but at the same time has similar applications. The first FPGA was released by Altera in 1984 which featured a quartz
window to erase the Erasable Programmable Read-Only Memory (EPROM) cells
that hold the configuration. It only had eight macrocells and a maximum frequency
of about 30MHz [2]. Today’s FPGAs can have several million logic elements with
several hundred MBs of Block RAM (BRAM), more than thousand floating-point
Digital Signal Processors (DSPs) and usual frequencies of more than 200MHz. However, the general idea of how FPGAs work stayed the same:
Field Programmable means that the FPGA can programmed in the application field,
even though configure is the better word to be used.
Gate Array stands for an array of logic gates which make up the FPGA. These
logic gates can then be freely routed by the developer and with that different logic
functions can be implemented.
FPGAs are built out of so called Configurable Logic Blocks (CLBs) which can be
connected with each other to create larger designs. Such a CLB contains several
different elements like Lookup Tables (LUTs), registers and Multiplexers (MUXs)
which allows one CLB to provide different functionality as needed. Each LUT can encode any kind of multi-bit boolean functionality. Figure 4.1 shows how a 2-bit LUT
is built out of three 2-to-1 MUXs. Depending on the input values of the SRAM
into the MUXs, a different logic function can be implemented. For example: For

43

4 FPGA Model

SRAM bits

0|1

A

0|1

1

0|1

0

0|1

1

0
MUX

MUX

Inputs

1

B

0
MUX

Output
Y

Figure 4.1: Internal structure of a 2-bit LUT
a NAND function, the SRAM is loaded with the bits 0111. In FPGAs these LUTs
usually take 4-6 bit inputs and can, therefore, implement more complex logic functions.
Combining these LUTs with registers, complex hardware DSPs and a lot more advanced hardware, modern FPGAs are very capable and complex devices that are
increasingly used in prototyping and low to medium quantity products. There are
several cheaply available FPGAs development boards that are very well suited for
a FPGA prototype of the EDiC.

4.2 FPGA choices
For the EDiC the Nexys A7 development board [9] with the AMD-Xilinx Artix 7
XC7A100T-1CSG324C FPGA has been chosen. Its synthesis tool is the AMD-Xilinx
Vivado [30] which is available as a free version and includes an advanced simulation
environment.

44

4.2 FPGA choices

65
66
67
68
69
70
71

assign s_cin[0] = i_ctrlAluSub;
for (i = 0; i < 8; i=i+1) begin
assign s_yXor[i] = i_a[i] ^ s_b[i];
assign s_yAnd[i] = i_a[i] & s_b[i];
assign s_yAdder[i] = s_cin[i] ^ s_yXor[i];
assign s_cin[i + 1] = s_yAnd[i] | (s_cin[i] & s_yXor[i]);
end
Code Example 4.1: Behavioral Verilog Description of the Adder (including
XOR and AND) of the ALU module.

4.2.1 Language Choice
There are two main Hardware Description Languages (HDLs): Verilog and VHSIC (Very High Speed Integrated Circuit) Hardware Description Language (VHDL).
Both are widely supported and used and can also be used in the same project with
the help of mixed-language compilation. At the Technical University Berlin (TUB)
VHDL is taught, however, in general both are used about equally often [22]. As Verilog is often cited as being less verbose and, therefore, easier to write and understand
it was chosen as the hardware description language.
Code example 4.1 shows the Adder described in Verilog as an example. It iterates
over all 8 bits, calculates the XOR and AND results and based on these and the
carry input, the bit result and the carry output is calculated.

4.2.2 Tri-state Logic in FPGAs
One major problem with tri-state bus logic for FPGAs is that most current era
FPGAs do not feature tri-state bus drivers in the logic slices. Most FPGAs do have
bidirectional tri-state transceiver for I/O but not for internal logic routing. However,
the HDLs (both VHDL and Verilog) support tri-state logic and the Xilinx Simulation
tool also does. Therefore, a simulation with tri-state logic would work but it cannot
be synthesized.
This is solved with a custom module for each tri-state network “tristatenet.v”. Each
tri-state driver exposes the current data and output enable signal to the tristate
module which then has only one output which represents the value of the net. If
none of the driver have an active output enable, the output is 0xff; if one of the
driver has an active output enable, the output represents its value and if more
than one driver have an active output enable, an error is raised. The modules logic
representation for a tri-state net with two inputs is shown in figure 4.2. The o_noe is

Niklas Schelten

45

4 FPGA Model

Figure 4.2: The elaborated tri-state module with two 8 bit inputs.
only active (low) if exactly one input i_noe is active (low) and depending on it, the
data output is selected. For this FPGA it is implemented with one LUT4 primitive
per output data bit.

4.3 Behavioral Implementation
Two kinds of FPGA designs were developed in the process. The first is a behavioral
description of the whole CPU and, therefore, only models the general workings
of a module but does not describe the individual chips that are used in the final
hardware assembly. The description in code example 4.1, for example, is a behavioral
description because it only describes the logical level of what should happen. This is
quite useful for development, because it is quickly changed and bugs are fixed more
eﬀiciently as opposed to a chip-level model.
To visualize how a behavioral simulation looks like, a simulation of the code in code
example 4.2 is shown in figure 4.3. The first instruction (mov r1, 0x12) starts at
1 µs where the instruction step counter is 0 and the instruction fetch is executed.
Step 1 increments the program counter and starts the instruction decoding. The
mov instruction only consists of one step and, therefore, the ctrInstrFinishedN
signal is asserted in step 2 together with the control signals of the actual instruction.
Due to ctrInstrFinishedN, the step counter is reset to 0 and the second instruction
(pc==1) is executed. After the instruction fetch steps, the ALU adds 0x12 and 0x42
at 2 µs and writes the result into r1 at step==3. The third instruction then just
branches to itself, resulting in an infinite loop.

46

Figure 4.3: Waveform of the relevant signals for setting a register to 0x12 and adding 0x2f to it (Assembler code is shown in code
example 4.2).

4.3 Behavioral Implementation

Niklas Schelten

47

4 FPGA Model

1
2
3
4

mov r1, 0x12
add r1, 0x2f
end:
b end
Code Example 4.2: The code for the waveform example of figure 4.3.

4.4 Chip-level Implementation
With the behavioral simulation working, the hardware schematic can be developed.
The schematic and then the placing and routing for the PCB is described in chapter 5. However, for the EDiC it was decided to add another verification step after
developing the schematic. From the schematic a netlist is generated which is usually
used to summarize all the components and connections in a machine readable format for the software that does placing and routing. Here, a tool was written which
converts a given netlist into a Verilog file which can be compiled and synthesized by
Vivado.

4.4.1 Conversation Script
The netlist file used is an *.edn which is exported by OrCAD/CAPTURE version
9.2.1.148. It follows the Electronic Design Interchange Format (EDIF) and contains
a list of all instances (i.e. ICs and other components) with port numbers and a
second list of all nets (connections between ports). The conversion script consists of
a parser which analyzes such a netlist. The parsed netlist is then further processed
until a verilog file can be created. The generated verilog file only consists of wire
definitions and module instantiations. Each of the instantiated modules has its own,
manually written implementation. The implementation for an 74F08 (quad AND
gate) is, for example, shown in code example 4.5.
Code example 4.3 specifies the instance U54 which is an 74AS867. The format also
specifies the port numbers but they are not processed by the parser because they
are not required. Code example 4.4 then specifies a net with the name PCIN0 which
connects U52 port 18 with U51 port 18 and U54 port 3. In this case U52 and U51
are both 74F245 octal bus transceivers where port 18 is the B0 tri-state output port
and U54 is a 74AS867 (synchronous up/down counter with load) where port 3 is the
D0 input port. Depending on the control signals of U51 and U52 this net connects
the 0th bit of the bus or the instruction immediate with the 0th bit of the load input
of the PC. Internally the list of instances and list of nets is combined into a list of

48

4.4 Chip-level Implementation

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31

(instance U54
(viewRef NetlistView
(cellRef &74AS867_0
(libraryRef OrCAD_LIB))) (designator "U54")
(property PCB Footprint (string "DIP.100/24/W.300/L1.175"))
(property Name (string "I656203"))
(property Value (string "74AS867"))
(portInstance &3)
(portInstance &4)
(portInstance &5)
(portInstance &6)
(portInstance &7)
(portInstance &8)
(portInstance &9)
(portInstance &10)
(portInstance &14)
(portInstance &22)
(portInstance &21)
(portInstance &20)
(portInstance &19)
(portInstance &18)
(portInstance &17)
(portInstance &16)
(portInstance &15)
(portInstance &13)
(portInstance &24)
(portInstance &12)
(portInstance &11)
(portInstance &23)
(portInstance &1)
(portInstance &2))
Code Example 4.3: An EDIF definition of an instance as exported by OrCAD/CAPTURE.

1
2
3
4
5
6
7

(net PCIN0
(joined
(portRef &18 (instanceRef U52))
(portRef &18 (instanceRef U51))
(portRef &3 (instanceRef U54)))
(property Name (string "PCIN0")))
Code Example 4.4: An EDIF definition of a net as exported by OrCAD/CAPTURE.

Niklas Schelten

49

4 FPGA Model

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

// quad and https://www.ti.com/lit/ds/symlink/sn74ls08.pdf
module ic74x08(
input wire port1,
input wire port2,
output wire port3,
input wire port4,
input wire port5,
output wire port6,
input wire port7,
output wire port8,
input wire port9,
input wire port10,
output wire port11,
input wire port12,
input wire port13,
input wire port14
);

18
19
20
21
22

assign port3 = port1 & port2;
assign port6 = port4 & port5;
assign port8 = port9 & port10;
assign port11 = port12 & port13;

23
24

endmodule
Code Example 4.5: Verilog implementation for the 74F08 IC.

instances where each instance contains a mapping of port numbers to connected
nets.
The parser discards all components except logic ICs (id starting with ‘U’) and
0 Ω resistors. The schematic includes some 0 Ω resistors between control signals
to be able to rewire them more easily on the PCB if needed. As they essentially behave as direct connections, the nets on either side of one 0 Ω resistor are
merged.
The basic instances are easily converted to verilog instantiations. However,
there are some obstacles that need to be taken with more advanced instances.

4.4.1.1 EEPROM
The 6 EEPROMs (3 for the instructionROM and 3 for the microcode) need to be
instantiated with the correct data loaded into them. Those six instantiations are

50

4.4 Chip-level Implementation

1364
1365
1366

1367

1368

microCodeRom inst_microCodeRom (
.clka(i_asyncEEPROMSpecialClock),
.addra({MC_A14, MC_A13, MC_A12, MC_A11, MC_A10, MC_A9, MC_A8,
,→
MC_A7, MC_A6, CTRLALUOP1_SRC, CTRLALUOP0_SRC, CTRLALUSUB_SRC,
,→
MC_A2, MC_A1, MC_A0}),
.douta({unconnected_U87_19, unconnected_U87_18,
,→
unconnected_U87_17, CTRLINSTRFINISHED_SRC,
CTRLMEMPCTORAM_SRC, CTRLMEMPCFROMIMM_SRC, CTRLMEMPCEN_SRC,
,→
,→
CTRLMEMRAMOE_SRC, CTRLMEMRAMWE_SRC,
,→
CTRLMEMINSTRIMMTORAMADDR_SRC, CTRLMEMMAR1WE_SRC,
,→
CTRLMEMMAR0WE_SRC, CTRLMEMINSTROE_SRC, CTRLMEMINSTRWE_SRC,
,→
CTRLMEMSPEN_SRC, CTRLMEMSPUP_SRC, CTRLMEMPCLOAD_SRC,
,→
CTRLREG1BUSOE_SRC, CTRLREG0BUSOE_SRC, CTRLREGALUSEL_SRC,
,→
CTRLREG1WE_SRC, CTRLREG0WE_SRC, CTRLALUOE_SRC,
,→
CTRLALUYWE_SRC})
);
Code Example 4.6: Verilog instantiation of the microcode ROM generated
out of three EEPROM instantiations.

identified by the unit id and the wires are then connected to one of the custom
Xilinx ROM IP Cores which are configured with the respective initial values. The
addresses for one ROM instantiations are used and then all 24 data ports from the
3 EEPROMs are connected resulting in a verilog instantiation as shown in code
example 4.6.

4.4.1.2 tri-state Ports
Some ICs provide tri-state ports. As discussed above, they cannot be implemented on
FPGAs and, therefore, need to be converted. The same tristatenet component as in
the behavioral implementation is used. However, for this to work, each bidirectional
port of the ICs needs to be replaced by one input and one output port. Also, one
output enable port needs to be added. Then the output port that replaced the
bidirectional port is connected to an input of the tristatenet instance and a new net
is created for each tristatenet which is the actual value of the net (the output of
the tristatenet module). The tristatenet for the PCIN0 signal (code example 4.4) is
represented by the instantiation shown in code example 4.7.

Niklas Schelten

51

4 FPGA Model

1794
1795
1796
1797
1798
1799
1800
1801

tristatenet #(
.INPUT_COUNT(2)
) inst_triBusPCIN0 (
.i_data({PCIN0_U51, PCIN0_U52}),
.i_noe({U51_b_noe, U52_b_noe}),
.o_data(PCIN0),
.o_noe(PCIN0_noe)
);
Code Example 4.7: Verilog instantiation for the tri-state Net PCIN0.

4.4.1.3 RAM and EEPROM clock
Another problem with the FPGA implementation in general is that both, the SRAM
and EEPROM chips used are asynchronous and the FPGA only has synchronous
logic elements. In the behavioral implementation, exact timings were no requirement
and, therefore, the memory and ROMs were clocked with the inverse clock, mimicking an asynchronous behavior. However, for the exact netlist FPGA implementation
this is not a good way to mimic the behavior. Therefore, the exact delay of both
chips were calculated with the help of the datasheets and they are both clocked with
a custom clock that is out of phase with the global logic clock by the exact amount
of the delay.
This means, that the clock inputs of the memory and EEPROM instantiations
are replaced with the corresponding custom clock as can be seen in code example 4.6.
Figure 4.4 visualizes how the main clock (CLK1 in the waveform) and the clock for the
ROM (asyncEEPROMSpecialClock in the waveform) differ in phase. Consequently,
the step register and with it the address for the microcode ROM change with a
rising edge of the main clock but all the control signals which are outputs of the
ROM change with the rising edge of the phase shifted clock.

4.4.1.4 Assignments
There are some connections which are unique to the FPGA implementation and,
therefore, are not contained in the netlist. These are mainly the inputs and outputs
of the CPU for the I/O extensions, the user buttons (reset, step etc.), clock oscillator,
breakpoint addresses and so on. However, one exception are the L1-L4 and H1-H4
nets which are static nets connected to ground or 5V through resistors. They are
used for logic inputs of ICs instead of directly using GND or 5V to ease the error

52

4.4 Chip-level Implementation

Figure 4.4: Waveform showing the clock used for the FPGA ROM to mimic
the asynchronous behavior of the EEPROMs.
fixing on the PCB. If one would connect the pins directly to the GND or 5V planes,
it would be hard to heat up the solder on the pin for removal because the whole
plane needs to be heated. Additionally, when connected to the plane, there is no
trace that can be scratched through if the pin needs to be connected to another
net.
In the FPGA design the nets L1-L4 and H1-H4 are, therefore, assigned to 0 or 1
respectively.

4.4.1.5 Display Driver
The hardware build will feature 2 displays for the built-in I/O which can be directly addressed with 4 bits to display hexadecimal digits. The FPGA development
board on the other hand, features simpler and more common 7-segment displays.
In total, there are 8 7-segment displays of which two are used as the built-in I/O
and the others are used for debugging when the CPU is halted. The wiring of the
displays is shown in figure 4.5. For this purpose, a custom displayDriver has been
developed which has 8 four bit data inputs for the digits plus 8 inputs for the dots
between the digits. Additionally, 8 bits encode which 7-segment displays should be
illuminated. It loops through the digits by setting each anode to 0 individually and
setting the cathodes according the corresponding input bits. This way, each display
is illuminated for 2ms which makes it look like all displays are illuminated all the
time.

Niklas Schelten

53

4 FPGA Model

Figure 4.5: Overview of the 8 7-segment displays of the Nexys A7 development
board [10].

4.4.2 RS232 I/O Extension Debugging
One goal of creating a logical replication of the CPU on a FPGA was to verify the
I/O extension cards before ordering the large PCB for the CPU. All extension cards
will be daughterboards and sit on top of the main PCB in a smaller form factor. The
following logical connections are passed through pin headers:
• Bus (8 bits, bidirectional)
• I/O Address (lower 8 bits, to I/O)
• Control Signals:
– ioCE: active when the upper 8 RAM address bits equal 0xfe.
– ctrlMemRamWE: write enable signal. Write should only happen when ioCE
is active.
– ctrlMemRamOE: output enable signal. Read should only happen when
ioCE is active.
– clk: Clock signal.
– reset: Reset signal.
Additionally, ground and 5V is passed through the connector. However, the Nexys
A7 FPGA development board only features digital 3V3 connections on the side.
Thus, an adapter board is required which converts the 3V3 voltages to 5V and the
other way around while providing the correct pin locations for the Nexys A7 board
and the daughterboard. Its schematic is shown in figure 4.6 where the 74LVC8T245
is used as a voltage converting buffer. For the control signals and addresses, its

54

Figure 4.6: The Schematic for the 3V3 to 5V conversion to use extension cards with the FPGA development board.

4.4 Chip-level Implementation

Niklas Schelten

55

4 FPGA Model
direction is always from the A port (3V3) to the B port. On the other hand, the
direction pin of the bus buffer is low (from B to A) when both, output enable and
chip enable, signals are active.

56

5 Hardware Design
After the FPGA behavioral simulation is successful, the hardware design process is
started. The initial step is designing a schematic (section 5.1) which is followed by the
netlist simulation and the placing and routing of components and wires in section 5.2.
Additionally, a timing analysis is performed to ensure that the clock frequency is as
high as it is possible without risking any misbehavior.

5.1 Schematic
The full schematics of the hardware design can be found in appendix A in figures A.1
to A.7. The schematic is created in such a way that the logical connections are easy
to understand. Each IC has its pins arranged for easy understanding and the connections have meaningful names to easier understand the logic.
The 74 series of ICs is used for the EDiC. However, a lot of decisions need to be
made in choosing the correct ICs.

5.1.1 Register Comparison
The 74 series of logic ICs feature many different registers. The most basic register
IC has n D-type flip-flops with respective data inputs and outputs plus one common
clock input. On each rising edge of the clock the flip-flops capture the input values
and hold them until the next rising edge of the clock. However, often it is required
that a register does not capture data on every rising edge of the clock. This is done
with an additional input, called clock enable. Implementing the clock enable with a
basic AND gate of the clock and a control bit has the major drawback that glitches
of the enable control signal can propagate to the clock input of the register and,
therefore, falsely trigger the register. There are two widely used alternatives to the
simple AND gate: The enable input can be used as the select input for an multiplexer
to the data input of the flip flop, where it multiplexes between the actual input and
the current output. This allows the flip-flop to always capture data but when the

57

5 Hardware Design

Figure 5.1: Clock Enable circuit of the 74F825 IC [6].
enable input is inactive, it recaptures the current output. The drawbacks are that
each bit of the register needs a multiplexer at the input and, furthermore, that the
flip-flops draw power on every clock pulse, even though no new data is captured. The
74F825 logic IC solves this with the circuit shown in figure 5.1. When the EN input
is low, NAND gate on the right negates the CP1 . When the EN input is high, on
the other hand, the output does not change. This circuit prevents the EN to trigger
a falling edge (which would trigger the flip-flops) on the CP output. However, when
the EN goes high while the CP input is high, then the output also goes high. This is
not directly a problem because the flip-flops only trigger on falling edges but is the
reason for timing requirements on the EN input which are discussed in more detail
in section 5.3.
As the registers store the current state of execution, it is required that the registers
start up to a known state. Therefore, some registers feature an asynchronous clear
input (or set input) which forces all flip-flops to 0 (or 1). This is usually accomplished
by modifying the classical D-type flip-flop to allow for setting and resetting the
internal SR NAND latches as shown in figure 5.2.
A third feature that may be important is a tri-state output which allows the register
to be directly connected to a bus. It is accomplished by adding a tri-state output
driver to the outputs of the flip-flops.
The register that was chosen for the EDiC is the 74F825 because it has all three
features and is 8 bits wide. However, three other kinds of registers are also sparsely
used in the EDiC:
• The 74AS867 is a more advanced synchronous counter register which is used
for the PC and SP. They are described below.
1

58

The internal flip-flops of the 74F825 are negative edge triggered

5.1 Schematic

Set

Q

Q
Clock

Clock
Q

Q

Data

Data

(a) Classical D-type flip-flop built out of
three SR NAND latches [23].

Reset

(b) D-type flip-flop modified to support
Clear and Set [27].

Figure 5.2: Comparison of D-type flip-flops with and without Clear and Set.
• The 74F374 register only features the output enable and is used once where
no additional control logic is required.
• The 74F273 is used for the built-in I/O to mimic the typical asynchronous
extension cards and for the buffering of user control inputs (stepping etc.)
because only a reset is required there.

5.1.2 LED Driver
The EDiC features many Light-Emitting Diodes (LEDs) showing the register contents to aid the understanding of the workings of a CPU. However, naively connecting the LEDs to the logic outputs of registers may lead to unwanted behavior
because the outputs of all logic ICs have a limited current they can provide. This
leads to the usage of specific buffers for the LEDs. Additionally, the current rating
usually is higher for low-level output due to the internal workings of the output
buffer. For example, the B outputs of a 74F245 non-inverting buffer are rated for
maximum −15 mA for high-level output and 64 mA for a low-level output [14]. Therefore, connecting the anode of a LED via a current limiting resistor to the output
of a non-inverting buffer and the cathode to GND will not be ideal. To be able to
draw more current from the buffer and thus having brighter LEDs, inverting buffers
are used and the LEDs are connected “backwards”. The 74ABT540 is the IC used
as LED buffer in the EDiC with the a low-level current rating of 64 mA [26]. The

Niklas Schelten

59

5 Hardware Design
cathodes of the LEDs are then connected to the 74ABT540 and the anodes are
connected through current limiting resistors to Vcc .

5.1.3 Program Counter & Instruction EEPROMs
Figure A.1 contains the PC (U54 and U55) with the instruction EEPROMs (U62,
U67, U69) and the registers to store the instruction. The PC can be incremented
or loaded from either an instruction immediate (U50 and U52) for branching or the
SRAM (U49 and U51) for returning from a function call. To facilitate these operations, the 74AS867 is used which is an 8 bit synchronous counter with loading and
asynchronous clear capabilities that can be cascaded with a ripple carry output. The
PC is then used as the address to the instruction EEPROMs and can also be saved
to the SRAMs. As the main memory is only 8 bits wide but the PC is 16 bit wide, a
second SRAM IC is used to store the upper bits of the PC in the case of a function
call (see section 5.1.4). The PC is, additionally, used as A inputs to the 74F521 (U53
and U60) comparators to detect when a breakpoint is reached. The 8 bit comparators can be cascaded via the enable input to compare 16 bit values. The B input is
selected by the user with four hexadecimal digit switches.
The function of the “Test” block between the output of the instruction EEPROMs
and the the instruction registers is explained in section 6.1. For understanding the
function of the schematic, it can be assumed that it shorts the connections on the
left with the corresponding connections on the right. The lowest of the 3 instruction
registers (U64) holds the instruction code which is used in the section 5.1.5. The
upper two registers (U70 and U71) hold the immediate value which can be used as
an address in the section 5.1.4, as a branch address for the PC and the lower 8 bits
can be used as immediate value on the bus (U75).
All 5 registers
tion 5.1.2.

have

LEDs

connected

to

them

as

described

in

sec-

5.1.4 Memory
The memory module (figure A.2) features three registers used for the address logic:
The MAR (U68 and U63) is a 16 bit register where the lower and upper 8 bits can
be loaded independently from the bus. The SP (U56) is a 74AS867 counter register
similar to the PC but only 8 bits wide and wired differently to only allow incrementing and decrementing. The three different kinds of memory accesses are decoded

60

5.1 Schematic
from the upper 8 address bits which either come from the instruction immediate
(U74) or the MAR (U73):
• I/O access: When the upper 8 bits equal 0xfe (U79), the I/O chip enable
(CE) signal is asserted and the SRAM CE is deasserted.
• Stack access: When the upper 8 bits equal 0xff (U76), the stack memory is
selected. Then the upper 8 bits of the address is replaced by the SP and a
17th address bit is asserted to access the stack memory.
The address is then driven by several bus driver according to the decoding logic
(U61, U63, U65, U66 and U72).
The actual SRAM ICs (U77 and U100) have voltage levels which are not quite
compatible with the standard 74F ICs [12] which is why all the signals connecting to them are buffered with the 74ACT245 [13] (U201, U202, U203, U204 and
U205).

5.1.5 Control Logic
Figure A.3 contains two registers for the address of the microcode EEPROMs (U85,
U86 and U87) of which the data pins are the control signals (section 2.3). The
first registers (U83) is used as a synchronous 3 bit step counter which increments
each cycle except when the halt signal is asserted. The instruction finished control
signal will reset the step counter to 0 at the next cycle. U83 also registers the four
ALU flags and U84 registers the instruction to synchronies all address bits for the
EEPROMs.

5.1.6 Clock and Reset
Figure A.4 contains the oscillator (X1) whose frequency is determined in section 5.3
and a active low reset controller (U34) which resets on power-on and can be combined
with a user reset switch (SW1301). The clock and reset is buffered with an 74ABT245
for minimal latency. To avoid glitches (see section 6.2) on the four user inputs, a low
pass and a Schmitt trigger and two registers are used. A multiplexer (U39) generates
the halt signal from the debug user inputs and the instruction finished control signal
to implement the logic described in section 2.2.7

Niklas Schelten

61

5 Hardware Design

5.1.7 Built-In I/O
The built-in I/O (figure A.5) consists of one register to hold the output value (U92)
which is connected to two hexadecimal displays (U93 and U94). For input two hexadecimal switches (SW10 and SW11) are used with a bus driver (U91). To control
the register clock pulse and the output enable of the bus driver, the I/O CE is
combined with the I/O write enable and I/O output enable and the I/O address is
compared with 0x00 (U88).

5.1.8 Register Set and ALU output
The register set in figure A.6 consists of two registers (U40 and U41) which can be
loaded from the bus. The register outputs can drive the bus (U44 and U45) and are
multiplexed for the A input of the ALU (U42 and U43). After the combinatorial
ALU (section 5.1.9), the four operation results are multiplexed (U5, U6, U7 and U8)
and stored in the ALU output register (U9). Even though the ALU output register
features output enable inputs, an indivual bus driver is used (U10) because the content of the ALU output register should be displayed to the user (U11). The carry
flags are also multiplexed (U101) as the carry flag from the shift operation is generated independently. The overflow flag is generated in the combinatorial schematic
of the ALU, the negative flag is just the MSB of the output and the zero flag is deduced from a comparison with zero (U12). All four flags are then stored in a register
(U97).

5.1.9 Combinatorial ALU
Figure A.7 shows the ripple carry adder on the left composed out of 8 full adder
and with subtracting capabilities. The barrel shifter on the right side is explained
in depth in section 2.2.1. The carry flag resulting from a shift operation should
always represent the last bit which was shifted out of the 8 bits and should be
unchanged when shifting by 0. This is accomplished with another multiplexer (U102).

5.2 Placing and Routing
After designing the schematic all the components need to be placed on the PCB.
All logic ICs are listed in table 5.1. For placing and routing several factors are

62

5.2 Placing and Routing

Table 5.1: All logic ICs used in the EDiC.
IC

Quantity

Function

74F245

17

Tri-state Octal Bus Transceiver

74ABT540

14

Inverting Octal Buffer (LED Driver)

74F157

12

Quad 2 to 1 multiplexer

74F825

10

Octal register with Tri-state, Asynchronous Clear and
Clock Enable

74F86

7

Quad XOR

74F08

7

Quad AND

74F521

6

8 bit Inverting Comparator with Enable

28C256

6

EEPROM with 15 address bits

74ACT245

5

Octal Bus Transceiver used for SRAM

74F153

4

Dual 4 to 1 multiplexer

74F32

4

Quad OR

BERG40

3

40 pin Connector for Test-Adapter

BERG26

3

26 pin Connector for Test-Adapter

74F151

3

8 to 1 multiplexer

74AS867

3

Synchronous 8 bit cascaded counter with loading

BERG10

2

10 pin Connector for Test-Adapter

74F273

2

Octal register with clear

74F04

2

Hex Inverter

AS6C4008

2

SRAM with 19 address bits

5082_7340

2

hexadecimal display

74ACT14

1

Hex Inverter with Schmitt Trigger

DS1813-10

1

Reset Generator

74F374

1

Octal register with output enable

74ABT245

1

Bus driver used for clock and reset

Sum

118

-

important. As the goal of the EDiC is to be easy to understand for future students,
all components were not only placed to optimize the wiring but a focus was to place
components of the same modules close together. Additionally, extra space was left to
mark each module and to name all the LEDs on the silkscreen of the PCB for easier
reference. Figure 5.3 is a rendering showing the traces (red and green), silkscreen
(violet) and through-holes/vias (green/yellow).
Especially on larger PCBs and designs with quickly switching power consumption it

Niklas Schelten

63

5 Hardware Design
is important to ensure good power delivery to all components. In the case of the EDiC
this is achieved by using a 4-layer PCB with the two internals layers being filled with
GND and 5V panes. The top and bottom layer are then used for logical connections
where the most eﬀicient wiring can be done when one layer mostly has vertical wires
(red traces in figure 5.3) and the other layer mostly horizontal wires (green traces).
This way interference between vertical and horizontal traces is not possible due to
the GND and 5V panes separating the logic panes.
Another important factor to bear in mind is to route the traces in a way that makes
it possible to access every trace on the PCB. It is always possible that some bug
was not detected in the schematic design or netlist simulation. If a bug has been
found it may be required to cut a trace and rewire it (see chapter 6). Therefore,
logical wires are always placed on the top or bottom pane and on the top pane
traces will never be completely covered by ICs. If, for example, connecting pins 1
and 24 of a 24 pin IC (they are directly opposite of each other) they should not be
connected directly but a detour should be taken to expose the trace from under the
IC.
It is also possible that a new IC needs to be placed on the PCB to fix a bug, like
an extra register or bus driver. Therefore, through holes are provided to allow spare
ICs to be placed at convenient locations throughout the PCB.

5.3 Timing Analysis
To figure out what the maximum frequency is at which the EDiC can operate on, a
detailed timing analysis was performed. The timing analysis computes the path
with the longest propagation delay which is called the critical path. The delay
of the critical path can then be used as a baseline for choosing the correct frequency.
Figure 5.4 visualizes how the propagation delays work: Each IC has delays which
are specified in the datasheet. In the example of figure 5.4, a value of register r0 goes
through a combinatorial path and is then stored in register r1 . The registers have
a propagation delay tp which specifies the time from a rising edge of the clock to
the output (Q). In theory it is also important to hold the input data of a register
for the specified hold delay th , however, in the EDiC this is no problem. Then the
combinatorial path also has propagation delays from inputs to outputs which need
to be added up (tc ). At the next register, a setup time ts has to be met which
specifies the amount of time the input data needs to be stable before the rising
edge.

64

5.3 Timing Analysis

Figure 5.3: Rendering with all components placed and all the traces routed on
the two logic layers (green and red).

Niklas Schelten

65

5 Hardware Design

clk
t_h

D[r0]

D0

D1

D2

t_p

Q[r0]

D0
t_c

D1
t_s

D2

t_h

Q[comb]/D[r1]

D0

D1

D2

t_p

Q[r1]

D0

D1

Figure 5.4: Timing relations for a combinatorial datapath between two registers.
The figures 5.5 to 5.7 show three timing analysis for the EDiC. Each block represents
one IC with the corresponding delay. The first row shows the unit number from the
schematic, the second line the type of IC, the third shows the kind of delay and the
fourth shows the amount of time. The kind of delay of a buffer can for example be
d→ q which means input data to output data delay or oe→ q which is the time
from asserting output enable until the data is valid. The delay time is always the
worst case time as specified in the datasheet2 . A vertical double line represents a
point where multiple delay paths must be met until the execution can continue. In
figure 5.5 for example, the propagation delay of register U83 (flags and step register)
and register U84 (instruction) must both be over until the address for the EEPROMs
U85, U86 and U87 are valid. At these points the maximum of the merging delay
paths is used as the starting point for the next path. The maximum delay up to
this point is also printed at the top. Additionally, some paths are labeled for clarity.
All the delays of the critical path (the path that takes the longest from one starting
point to one end point) are marked in red.
Figure 5.5 shows the basic latency path for control signals and the common bus
driver ICs. The latencies inside the register set and program counter are neglectable
and, therefore, only the memory module with the complex address decoding and the
ALU is further examined. For the memory module (figure 5.6), there are two critical
paths: The first comes from the memInstrToRamAddr control signal, through the
stack selection logic to the memory address and finally to the buffered output data
of the SRAM on the bus (281.3 ns). The second has the same origin but represents
the writing option of the SRAM (272.2 ns).
2

Propagation typically varies with the temperature and age of the IC and by taking the worst
case time (maximum) it is assured that no timing bugs occur due to e.g. weather changes.

66

5.3 Timing Analysis
10.5ns

U83
74F825
cp->q
10.5ns

U85/U86/U87
28C256-15
d->q
150ns

U84
74F374
cp->q
10ns

all control
signals
160.5ns

U44/U45/
U75/U99
74F245
oe->q
9.5ns

bus
169.5ns

aluOp[1:0]
aluSub
10.5ns

Figure 5.5: Timing analysis for the control signals.
The ALU latency path (figure 5.7) is more complex which is mainly due to the
ripple carry adder. Consequently, the critical path comes from the bus, through all
the carry flags to the final adder result. After the result multiplexer the longest path
is from the zero flag to the alu flag register U97 (313.9 ns).
Theoretically, it is possible for one instruction to read a value from the SRAM and
using it in the same instruction as an input to the ALU. This would replace the
baseline delay of the bus input in figure 5.7 (169.5 ns) with 281.3 ns and, therefore,
enlarge the total worst case latency to
281.3 ns − 169.5 ns + 313.9 ns = 425.7 ns

(5.1)

Notwithstanding, because the EDiC is a multicycle CPU it is easily possible to assign
two cycles to all ALU operations where the B operand is read from the memory. With
this trick, the overall critical path is the maximum of 313.9 ns and 425.7 ns/2 which is
313.9 ns. With a safety margin of 30% it is feasible to choose an oscillator with a
frequency of 2.4 MHz:
2.4 MHz ⩽

1
= 2.45 MHz
1.3 · 313.9 ns

(5.2)

When dealing with circuits that are designed to run right at the critical path or
with very long trace lengths another factor needs to be taken into account which
is neglected here. Each signal has a latency in traces and when the clock arrives
at the second register earlier than at the first register, the time allowed for the
combinatorial path is shorter than the theoretical clock period. However, for the
EDiC this is not a problem as shown in section 6.2.2.

Niklas Schelten

67

5 Hardware Design

U
74
cp
10

controlSignal
160.5ns

memInstrImmToRamAddr

U70/71
74F825
cp->q
10.5ns

U68
74F825
cp->q
10.5ns

controlSignal
160.5ns

instrImm

U6
74
a

mar[15:8]

U
74
a

U48A
74F04
d->y
6ns

memInstrToRamAddr

U
74
oe
11

U
74
oe
186.5ns

U38C
74F08
d->y
6.6ns

175.5ns

U70/71
74F825
cp->q
10.5ns

instrImm

U68
74F825
cp->q
10.5ns

U74
74F245
a->b
7ns

mar[15:8]

U73
74F245
a->b
7ns

controlSignal
160.5ns

memInstrToRamAddr

U73
74F245
oe->b
9ns

controlSignal
160.5ns

memInstrToRamAddr

U48A
74F04
d->y
6ns

U48F
74F04
d->y
6ns

U
74
oe

U
74
oe

186.5ns
U76
74F521
a/b->q
11ns

select

controlSignal
160.5ns

U38D
74F08
d->y
6.6ns

U48C
74F04
d->y
6ns

U
74
oe

memInstrToRamAddr

U56
74AS867
cp->q
16ns

U74
74F245
oe->b
9ns
U48B
74F04
d->y
6ns

mar[15:8]

U
74
a

ramCE

controlSi
160.5n

Figure 5.6: Timing analysis for the memory latency.
68

5.3 Timing Analysis

U63
74F825
cp->q
10.5ns

mmToRamAddr

instrImm

U63
74F825
oe->q
11.5ns

U65/66
74F245
a->b
7ns
208.1ns

mar[15:8]

U72
74F245
a->b
7ns

U65
74F245
oe->b
9ns

U72
74F245
oe->b
9ns
272.2ns

controlSignal
160.5ns

U66
74F245
oe->b
9ns

217.2ns
U202/203
74ACT245
a/b->b/a
9.1ns

bus
281.3ns

U77
AS6C4008
read
55ns

U61
74F245
oe->b
9ns

mar[15:8]

U201
74ACT245
a/b->b/a
9.1ns

U204
74ACT245
a/b->b/a
9.1ns

U61
74F245
a->b
7ns

U204
74ACT245
a/b->b/a
9.1ns

controlSignal
160.5ns

controlSignal
160.5ns

U204
74ACT245
a/b->b/a
9.1ns

U48E
74F04
d->y
6ns

U204
74ACT245
a/b->b/a
9.1ns

217.2ns

U77
AS6C4008
write
55ns
bus
169.5ns

U201
74ACT245
a/b->b/a
9.1ns

controlSignal
160.5ns

U201
74ACT245
oe->b/a
13.1ns

Niklas Schelten

ram write
272.2ns

178.6ns

69

5 Hardware Design
285.9ns
xor 185.5ns
and 184.1ns
185.5ns

xor0
U2/3
74F86
a/b->y
8ns

b_x

controlSignal
160.5ns

r_xy

ctrlRegAluSel

U42/43
74F157
a/b->y
7ns

a_x

U42/43
74F157
sel->y
11ns

a_x

U23/28
74F86
a/b->y
8ns
U24/29
74F08
a/b->y
6.6ns

U27D
74F32
a/b->y
6.6ns

and0

xor_x

U5
74
a/

184.1ns
198.7ns

U13/14
74F157
a/b->y
7ns

a reversed

U13/14
74F157
sel->y
11ns

a reversed

adder4
246.3ns

U25C
74F86
a/b->y
8ns

and_x

controlSignal
160.5ns
adder5
259.5ns

U26C
74F08
a/b->y
6.6ns

178.5ns

ctrlAluSub

adder2
219.9ns

adder3
233.1ns

xor1

ctrlAluSub
10.5ns

192.1ns

177.5ns

171.5ns

U40/41
74F825
cp->q
10.5ns

adder1
206.7ns

U26D
74F08
a/b->y
6.6ns

185.5ns

bus
169.5ns

adder0
195.5ns

U25D
74F86
a/b->y
8ns

aluSub
10.5ns

205.3ns

U27C
74F32
a/b->y
6.6ns

and1

adder6
272.7ns

bus
169.5ns

adder7
285.9ns

211.9ns
U25B
74F86
a/b->y
8ns

U26B
74F08
a/b->y
6.6ns

xor2

U1
74
a/

shift
206.5ns

a reversed

218.5ns

U27B
74F32
a/b->y
6.6ns

225.1ns
U25A
74F86
a/b->y
8ns
264.7ns
U26A
74F08
a/b->y
6.6ns

xor3

U3
74F
a/b
8n

231.7

U27A
74F32
a/b->y
6.6ns

238.3ns
U30D
74F86
a/b->y
8ns

xor4

U31D
74F08
a/b->y
6.6ns

244.9ns

U32D
74F32
a/b->y
6.6ns

and4

251.5ns
U30C
74F86
a/b->y
8ns

xor5

U31C
74F08
a/b->y
6.6ns

258.1ns

and5

Figure 5.7: Timing analysis for the ALU latency.
70

U32C
74F32
a/b->y
6.6ns

xor6

U3
74F
a/b
6.6

5.3 Timing Analysis

296.9ns
U9
74F825
setup enable
1ns

controlSignal
160.5ns

alu out register
U9
74F825
setup data
3ns

controlSignal
160.5ns

293.9ns
U5/6/7/8
74F153
a/b->y
8ns

U12
74F521
d->y
11ns

U5/6/7/8
74F153
sel->y
12ns

controlSignal
160.5ns

U104A
74F04
d->y
6ns

U97
74F825
setup enable
1ns

U97
74F825
setup data
3ns

zero flag

negative flag

313.9ns

alu flags

U97
74F825
setup data
3ns

199.5ns
U97
74F825
setup data
3ns

185.5ns

bus
169.5ns

shift 4 y
U21/22
74F157
a/b->y
7ns

shift 1 y
shift 2 y

U17/18
74F157
a/b->y
7ns

ctrlAluSub
10.5ns

a reversed

U97
74F825
setup data
3ns

206.5ns

U19/20
74F157
a/b->y
7ns

192.5ns

U15/16
74F157
a/b->y
7ns

ns

U19/20
74F157
sel->y
11ns

bus
169.5ns

U15/16
74F157
sel->y
11ns

ctrlAluSub

U21/22
74F157
sel->y
11ns

U17/18
74F157
sel->y
11ns

bus
169.5ns

185ns

U102
74F151
d->y
7.5ns

264.7ns

xor6

U102
74F151
sel->y
12ns

bus
169.5ns

U30B
74F86
a/b->y
8ns

U31B
74F08
a/b->y
6.6ns

flagCarryShift

271.3ns
flagAdderCarry
291.1ns

and6

U32B
74F32
a/b->y
6.6ns

298.6ns
U101
74F151
d->y
7.5ns

U101
74F151
d->y
7.5ns

flagCarry

U101
74F151
sel->y
12ns

ctrlAluOp[1:0]
10.5ns

277.9ns
U30A
74F86
a/b->y
8ns

xor7

299.1ns

U31A
74F08
a/b->y
6.6ns

284.5ns

flagOverflow

and7

Niklas Schelten

U81A
74F86
a/b->y
8ns

U32A
74F32
a/b->y
6.6ns

U81A
74F86
a/b->y
8ns

71

6 Initial Hardware Test &
Component Verification
Even though the netlist was simulated and tested in the FPGA implementation,
there is no guarantee that the hardware will work out of the box. Therefore, all bits
of all components are to be tested individually to make sure there are no wiring
problems which would result in bugs which are hard to pinpoint and debug. Testing
single ICs, especially with tri-state logic, is significantly easier when incrementally
adding ICs to the PCB. That way one driver of a tri-state net can be verified and
when adding another driver to the net, problems can be pinpointed to the new IC
because the first one was known to work correctly. Therefore, all ICs are placed
inside sockets. This way all resistors, LEDs and sockets can be soldered to the PCB
at once and all the ICs can be placed in their sockets consecutively. Another reason
for using sockets is that it is easier to change an IC if it is faulty or breaks in the
future.

6.1 Test Adapter
To facilitate the testing, all control signals including clock and reset, the instruction
register inputs and the ALU results + flags are interrupted by connectors at the
side of the PCB which can connect to test adapter boards for testing. For the debug
signals that are not busses the test adapter has LEDs to display the state of the
EDiC and DIP Switches to set each debug signal to a known value. Additionally,
the main bus and ram2data bus is connected to a test adapter but not interrupted.
The test adapter has LEDs for displaying the state and a bus driver with DIP
Switches. If not testing, the connectors can be bridged with shorting connectors
which short the pins from the left to the right column (except the two tri-state
busses).
Testing the individual components becomes very simple this way. For example the
instruction registers:

73

6 Initial Hardware Test & Component Verification
1. Set each bit of the data input individually from the test adapter
2. Assert the memInstrNWE control signal (set to 0)
3. Trigger a clock pulse
4. Verify that the output lines equal the input set on the test adapter
All ICs, including the EEPROMs and SRAMs can be directly tested in a couple
simple steps this way.
The advantage of individually testing all the bits of all ICs is that in integration testing one can assume that the problem is not with one specific IC.

TODO: Insert part of a schematic of one test
adapter?

6.2 Potential Complications
As is normal with large designs, there were some potential problems found in the
EDiC which needed fixing.

6.2.1 Shifter - Carry Flag
The detailed testing with the test adapter did reveal one bug which was not revealed
in the netlist simulation because it did not occur in any simulated program. The
carry flag of a shift operation is determined by the 8 to 1 multiplexer U102 in
figure A.7 with the first 3 bits of the bus as select bits. The carry should always be
the last bit that was shifted out of the 8 bit word. This way, the input D1 (a0) is set
as the new carry flag when shifting by 1 bit, D2 (a1) when shifting by 2 bits and so
on. However, the input D7 is connected to a7 and not a6 as it should be. This results
in a wrong carry flag when shifting by 7 bits in either direction.
In the netlist simulation this bug was not found because there was no circumstance
where a value with differing bits 7 and 8 was shifted by 7 bits and the carry flag being
used in the next instruction. These kind of bugs can go undetected for a very long
time and are very hard to pinpoint with a fully running CPU.

74

Niklas Schelten
(d) Latency

(c) R232 = 0 Ω and 100 Ω termination

Figure 6.1: Comparison of the rising edge of the clock in different configurations. Measured close to the clock buffer (yellow) and
in figure 6.1d at the end of a clock lane (U204 pin 8) (green).

(b) R232 = 33.3 Ω

(a) No modification

6.2 Potential Complications

75

6 Initial Hardware Test & Component Verification

6.2.2 Clock jitter
Especially with larger PCBs a good clock distribution is a must-have. Long clock
lanes with a large load (i.e. many connected components) may induce several unwanted effects:
• Jitter in the rising edge due to reflection from the ends of clock traces.
• A less steep rising edge due to an implicit RC-low pass filter with capacitive
loads from the clock inputs and wire resistor.
• Over and undershoot after the edges exceeding the maximum rated voltage.
• Clock latency between ICs reducing the time between two registers.
The effects must all be checked and kept under control. The clock lane for the
EDiC was not routed as one continues trace and rather similar to a clock tree
split in two. This reduces the maximum distance one clock input is away from the
clock source (U95 in figure A.4). In the schematic design additional clock buffers
were implemented to allow further splitting of the clock tree to help with clock
distribution if it occurs and cannot be fixed other ways.
Without any modifications, the clock looked like shown in figure 6.1a1 . It can be
seen that there is only a little bit of overshoot but at about the middle of the rising
edge there is a dip of about 500 mV. This could lead to a double trigger where the
rising edge is detected as two individual rising edges in a register and, therefore, a
counter could increment by two instead of by one. Therefore, an attempt was made
to circumvent this by changing R232 (a resistor in series after the clock buffer) from
0 Ω to a larger value. In figure 6.1b a 33.3 Ω resistor was added. It becomes obvious
that the time constant of the implicit low-pass filter increased and with it the edge
becomes less steep but the dip also becomes less of an impact. Even though this
is a decent improvement, it is not perfect. The next attempt was to add a line
termination of 100 Ω at the end of both clock lines instead of the 33.3 Ω resistor in
series. The result can be seen in figure 6.1c. It shows that the dip in the rising edge
is no longer there and the edge is also as steep as without any modifications. Even
though the overshoot changed a bit, it is by no means a problem and, therefore, this
solution looked promising.
Figure 6.1d zooms into the rising edge and shows the edge at U204 pin 8 (one end
of the clock tree) in green. It can be seen that the edge looks a bit different which
may be explained by the different behavior of different probes in the small time
1

76

figures 6.1a and 6.1b have AC coupling enabled which is why the y scaling is off.

6.2 Potential Complications

1
2
3
4
5

SIMPLE_IO = 0xfe00
mov r0, 0x42
loop:
str r0, [SIMPLE_IO]
b loop
(a) First test program.

1
2

SIMPLE_IO = 0xfe00
UART_SCR = 0xfe0f

3
4
5
6
7
8
9

1

ldr r0, [SIMPLE_IO]
str r0, [UART_SCR]
loop:
ldr r1, [UART_SCR]
str r1, [SIMPLE_IO]
b loop
(b) Second test program.

2
3

s:
call function
b s

4
5
6
7

function:
add r0, 1
ret
(c) Third test program.

Code Example 6.1: Test programs for integration testing.
scale. Additionally, the latency of the clock signal can be observed which is about
6 ns. The clock frequency was chosen in section 5.3 to have a safety margin of about
30% and, therefore, a latency of 6 ns is not a problem with a clock period of 416.7 ns
(2.4 MHz).

6.2.3 Driving Bus High
Until now, no program was programmed into the EEPROMs and it was time for the
first real integration test of the EDiC. The first program used for the integration
test in code example 6.1a was a basic test to see if basic instructions get executed
and if the built-in I/O works. After it ran successfully and displayed 0x42 at the
displays, the second testing program from code example 6.1b included the RS232
I/O extension card and its scratch register (at address 0xfe0f). When this also ran
successfully, a more complex Universal Asynchronous Receiver-Transmitter (UART)
echo program (code example B.3) was programmed into the EEPROMs. It finally
had problems and did not work as expected. It could be observed that the PC would
randomly be set to a unreasonably high value and after that NOPs were executed
until the PC overflowed to 0 and the program started again. However, when turning
on the cycle by cycle debugger and stepping through all cycles, the program worked
perfectly and bytes got read correctly from the RS232 extension card and were also
sent back correctly. After debugging for a long time, the bug was tracked down

Niklas Schelten

77

6 Initial Hardware Test & Component Verification

Figure 6.2: Write Enable of MAR register (green) and one bus lane without
0xff driver (yellow).
to the return instruction which sometimes (about 1 in 100 times) would return to
a random instruction and not return to after the call instruction. It was further
debugged with the third test program (code example 6.1c). With an oscilloscope it
was finally possible to detect the problem which is shown in figure 6.2. It is actually a
bug in both, the call and return instruction, which results in the same misbehavior
of return to a wrong location: Both instruction load 0xff into the MAR by not
driving the bus with a specific value and relying on the pull-up resistors to pull the
lines high. In figure 6.2 two MAR write enable pulses can be seen and, especially,
in the first pulse, the problem becomes apparent. If the bus was pulled low in the
cycle before the MAR is written, the pull-up resistors take some time to pull the
voltage to 5 V which leaves the level at about 2 V at the time of the write pulse.
This is right at the required minimum voltage to be detected as a high signal by the
74F825. Therefore, most of the time, the register detects the bus input as a 1 but
sometimes it is detected as a low signal.
The fix is quite easy as soon as the problem is detected: A new bus driver (74F245) is
added in one of the spare slots whose A input is connected to H1, the B input to the
bus and the output enable signal is connected to a new control signal. This fix would
have been very diﬀicult if no output of the microcode EEPROMs would have been
free to use or if no place for spare ICs was left on the PCB. Therefore, it is always
important to design everything with enough resources left.

78

6.2 Potential Complications

Figure 6.3: Write Enable of MAR register (green) and one bus lane with 0xff
driver (yellow).
The result of the fix can be seen in figure 6.3 where the bus line is raised to about
3.8 V as soon as the write enable pulse starts2 .

6.2.4 UART Transceiver lost data
The final bug was only observed with the test adapter and never while running the
EDiC on its own. One of the integration tests was to manually write a value from
the test adapter to the scratch register of the UART IC (TL16C550AN) on the
RS232 extension card and then read it out repeatedly. It could be observed that
the data was read back successfully for a couple of times but often the data would
be read back incorrectly after several reads. However, in the automated test with
the program from code example 6.1b, the data was still correctly displayed at the
built-in I/O after half an hour which results in about 300 million reads without
errors3 :
2.4 MHz
· 1800 s ≈ 309 · 106
(6.1)
14

2

The even higher level on the bus line after the write enable pulse is driven by the SRAM
driver (outputs the return address in the return instruction) which is an ACT type for compliance
with the SRAM specification. In figure 6.2 the SRAM probably drove a ‘0’ to the bus line.
3
2.4 MHz, 14 cycles per loop iteration and 1800 seconds run time

Niklas Schelten

79

6 Initial Hardware Test & Component Verification

Figure 6.4: DIP Switch output on switching (yellow).
The only notable difference between the two tests is that in the manual test, the
output enable signal to the UART IC was set by hand with a DIP Switch and in the
automated test, it was controlled by the output of the EEPROM. When looking at
the waveforms of the signal coming from the DIP switch, a bouncing of the trigger
can sometimes be observed as shown in figure 6.4. In theory this should not have an
effect on the content of the scratch register of the UART IC as the glitch happens
on the output enable input of the IC. However, the datasheet explicitly states a
minimum time for a read strobe pulse duration of 80 ns. For this reason, the test
adapter was altered to include a low pass filter and schmitt trigger on the memRamNOE
and memRamNWE control signals because those are the only control signals which are
used asynchronously. All other control signal are only used in components which do
not state a minimum pulse duration for it (only setup and hold times in relation to
the rising edge of the clock). After implementing this fix, the manual test worked
perfectly for many read cycles which means that the minimum read pulse duration
for the UART IC needs to be respected.
Even though, the problem never occurred with the control signals coming from
the microcode EEPROM, we looked into the specifications for the EEPROM and
found it also has a period after the address inputs change where the data output is
undefined. When observing the output with the oscilloscope, it was observed that
there sometimes are glitches on the memRamNOE control signal as shown in figure 6.5.

80

6.2 Potential Complications

Figure 6.5: Output of the memRamNOE control signal from the EEPROM (yellow).
Therefore, it was decided to add a register to the memRamNOE and memRamNWE control signals. This results in the microcode needing adjustment to assert these two
signals one cycle earlier which was easy to implement and prevented the problem
completely.

Niklas Schelten

81

7 Conclusion and Future Work

83

Acronyms
Notation Description
ALU
Arithmetic Logic Unit i–iii, 9–11, 13–15, 18, 20, 21,
24, 25, 27, 28, 30, 33, 45, 46, 61, 62, 66, 67, 70, 73,
89, 91, 93
ASIC
Application-Specific Integrated Circuit 43
BRAM

Block RAM 43

CE
CISC
CLB
CMOS
CPU
CSON

chip enable 61, 62
Complex Instruction Set Computer v, vi, 7–9, 13
Configurable Logic Block 43
Complementary metal-oxide-semiconductor 3
Central Processing Unit v, vi, 1, 3, 4, 6–11, 13,
15–18, 25, 28, 43, 46, 52–54, 59, 67, 74
CoffeeScript-Object-Notation 25

DIL
DIP
DSP

dual in-line 3
dual in-line package 4
Digital Signal Processor 43, 44

EDiC

Educational Digital Computer i, iii, v, vi, 1–3, 6–
11, 13–18, 20, 21, 25, 28–31, 35–38, 40, 41, 43, 44,
48, 57–59, 63, 64, 66, 67, 73, 74, 76, 77, 79, 89, 91,
93, 94, 99, 100, 102, 104, 106, 108, 110, 112, 115,
124
Electronic Design Interchange Format 48, 49, 93
Electrically Erasable Programmable Read-Only
Memory ii, 8, 14, 25, 28–30, 50–53, 60, 61, 63, 66,
74, 77, 78, 80, 81, 89, 90, 93
Erasable Programmable Read-Only Memory 43

EDIF
EEPROM

EPROM

85

Acronyms
Notation Description
FPGA

Field Programmable Gate Array ii, v, vi, 1, 4, 6,
43–46, 48, 50–57, 73, 89

HDL

Hardware Description Language 45

I/O
IC
IDE
ISA

Input / Output i, ii, v, 3, 7, 15–17, 19, 22, 45, 52–54
Integrated Circuit v, vi, 1–5, 7, 16, 48, 50–52, 57–
64, 66, 73, 74, 76, 78–80, 89, 91, 93
Integrated Development Environment 40
Instruction Set Architecture v, vi

JSON

JavaScript Object Notation 25

LED
LSB
LUT

Light-Emitting Diode 59, 60, 63, 73
Least Significant Bit 14
Lookup Table 43, 44, 89

MAR
MSB
MUX

Memory Address Register 16, 17, 19, 20, 22–24, 34,
60, 61, 78, 79, 90
Most Significant Bit 11, 13, 39, 62
Multiplexer 43

NOP

No Operation 24, 77

PC

Program Counter i, 8, 9, 13, 14, 16–19, 24, 27, 35,
36, 48, 58, 60, 77
Printed Circuit Board 4, 6, 18, 43, 48, 50, 53, 54,
62–64, 73, 76, 78
Pseudo Random Number Generator 31, 32, 37, 93,
94, 123

PCB
PRNG

RAM
RISC
ROM
RTL

86

Random-Access Memory ii, 19, 52, 54
Reduced Instruction Set Computer 8
Read-Only Memory 7, 52, 53, 89
Register-transistor logic v, vi, 3, 6

Acronyms
Notation Description
SMD
surface-mounted device 3
SP
Stack Pointer 16, 17, 19, 22–24, 34, 35, 58, 60, 61
SRAM
Static Random-Access Memory 7, 8, 15, 16, 19, 43,
44, 52, 60, 61, 63, 66, 67, 74, 79
TTL
TUB

Transistor-transistor logic i, v, vi, 3–5, 7, 89
Technical University Berlin 45

UART

Universal Asynchronous Receiver-Transmitter iii,
77, 79, 80, 94, 124

VHDL

VHSIC (Very High Speed Integrated Circuit)
Hardware Description Language 45

Niklas Schelten

87

List of Figures
1.1
1.2
2.1
2.2

The final version of the EDiC playing Snake on a VT-100 over an
RS-232 I/O card. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
TTL NAND with “totem-pole” output stage as in the 7400 IC. [21] .

2
5

1 bit full adder with the usual A, B and Carry inputs and Y and
Carry outputs as well as the XOR and AND outputs. . . . . . . . . . 10
8 bit bidirectional barrel shifter. . . . . . . . . . . . . . . . . . . . . . 12

3.1

The syntax highlighting with the EDiC Visual Studio Code Extension
and the Atom One Light Theme [1]. . . . . . . . . . . . . . . . . . . 41

4.1
4.2
4.3

Internal structure of a 2-bit LUT . . . . . . . . . . . . . . . . . . . .
The elaborated tri-state module with two 8 bit inputs. . . . . . . . .
Waveform of the relevant signals for setting a register to 0x12 and
adding 0x2f to it (Assembler code is shown in code example 4.2). . .
Waveform showing the clock used for the FPGA ROM to mimic the
asynchronous behavior of the EEPROMs. . . . . . . . . . . . . . . .
Overview of the 8 7-segment displays of the Nexys A7 development
board [10]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Schematic for the 3V3 to 5V conversion to use extension cards
with the FPGA development board. . . . . . . . . . . . . . . . . . . .

44
46

58
59

5.4
5.5
5.6
5.7

Clock Enable circuit of the 74F825 IC [6]. . . . . . . . . . . . . . . .
Comparison of D-type flip-flops with and without Clear and Set. . . .
Rendering with all components placed and all the traces routed on
the two logic layers (green and red). . . . . . . . . . . . . . . . . . . .
Timing relations for a combinatorial datapath between two registers.
Timing analysis for the control signals. . . . . . . . . . . . . . . . . .
Timing analysis for the memory latency. . . . . . . . . . . . . . . . .
Timing analysis for the ALU latency. . . . . . . . . . . . . . . . . . .

6.1

Comparison of the clock rising edge in different configurations. . . . . 75

4.4
4.5
4.6

5.1
5.2
5.3

47
53
54
55

65
66
67
68
70

89

List of Figures
6.2

6.4
6.5

Write Enable of MAR register (green) and one bus lane without 0xff
driver (yellow). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Write Enable of MAR register (green) and one bus lane with 0xff
driver (yellow). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DIP Switch output on switching (yellow). . . . . . . . . . . . . . . .
Output of the memRamNOE control signal from the EEPROM (yellow).

A.1
A.2
A.3
A.4
A.5
A.6
A.7

Schematic: Program Counter / Instruction ROM. . . . . . . . . . . . 100
Schematic: RAM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Schematic: Microcode. . . . . . . . . . . . . . . . . . . . . . . . . . . 104
Schematic: Clock and Reset. . . . . . . . . . . . . . . . . . . . . . . . 106
Schematic: Built-In I/O. . . . . . . . . . . . . . . . . . . . . . . . . . 108
Schematic: Register Set + ALU output. . . . . . . . . . . . . . . . . 110
Schematic: combinatorial ALU. . . . . . . . . . . . . . . . . . . . . . 112

6.3

90

78
79
80
81

List of Tables
2.1

Summary of the available ALU operations. . . . . . . . . . . . . . . . 11

3.1

All available branch instructions with their op-code and microcode
translation based on the ALU flags explained in section 2.2.1. . . . . 30

5.1

All logic ICs used in the EDiC. . . . . . . . . . . . . . . . . . . . . . 63

91

List of Code Examples
3.1

Schema of the Microcode Definition CSON-File [3] as a TypeScript
[19] Type definition. . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.2 Example definitions of one control signal and the instruction fetch
cycles for the microcode generation. . . . . . . . . . . . . . . . . . . . 27
3.3 Definition of the move immediate to register instruction for the microcode generation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 Definition of the alu operation with two register arguments for the
microcode generation. . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.5 Definition of the branch instructions. . . . . . . . . . . . . . . . . . . 29
3.6 PRNG written in the EDiC Assembler. . . . . . . . . . . . . . . . . . 31
3.7 The output of the PRNG of code example 3.6. The first 16 bits are
the memory address, then 8 bits for the instruction op-code and 16
bits for the instruction immediate and for reference the original instruction with variables replaced. . . . . . . . . . . . . . . . . . . . . 32
3.8 The PRNG of code example 3.6 with the constants and labels resolved. 37
3.9 Excerpts of the Snake assembler program used in the demo in figure 1.1. 38
3.10 The instructions resulting from the string definition of code example 3.9 line 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.1

4.7

Behavioral Verilog Description of the Adder (including XOR and
AND) of the ALU module. . . . . . . . . . . . . . . . . . . . . . . . . 45
The code for the waveform example of figure 4.3. . . . . . . . . . . . 48
An EDIF definition of an instance as exported by OrCAD/CAPTURE. 49
An EDIF definition of a net as exported by OrCAD/CAPTURE. . . 49
Verilog implementation for the 74F08 IC. . . . . . . . . . . . . . . . . 50
Verilog instantiation of the microcode ROM generated out of three
EEPROM instantiations. . . . . . . . . . . . . . . . . . . . . . . . . . 51
Verilog instantiation for the tri-state Net PCIN0. . . . . . . . . . . . . 52

6.1

Test programs for integration testing. . . . . . . . . . . . . . . . . . . 77

4.2
4.3
4.4
4.5
4.6

B.1 The full snake assembler program. . . . . . . . . . . . . . . . . . . . . 115

93

List of Code Examples
B.2 The PRNG assembler program “prng.s” used in the snake program
in code example B.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
B.3 The utility library for the UART extension card of the EDiC with
the 16c550 UART Transceiver. . . . . . . . . . . . . . . . . . . . . . 124

94

Bibliography
[1] Mahmoud Ali. Visual Studio Code - One Light Theme based on Atom. 2022.
url: https://marketplace.visualstudio.com/items?itemName=akamud.
vscode-theme-onelight.
[2] Altera. User-Configurable Logic Databook. (WWW). 1988. url: http://www.
bitsavers . org / components / altera / _dataBooks / 1988 _ Altera _ Data _
Book.pdf.
[3] bevry. CoffeeScript-Object-Notation. 2022. url: https : / / github . com /
bevry/cson.
[4] Crystal Chen, Greg Novick, and Kirk Shimano. RISC Architecture. 2000. url:
https://cs.stanford.edu/people/eroberts/courses/soco/projects/
risc/risccisc/.
[5] B. Jack Copeland. “The Modern History of Computing”. In: The Stanford Encyclopedia of Philosophy. Ed. by Edward N. Zalta. Winter 2020. Metaphysics
Research Lab, Stanford University, 2020.
[6] Fairchild Semiconductor Corporation. 74F8258-Bit D-Type Flip-Flop. 2000.
url: https://rocelec.widen.net/view/pdf/d4zabtdsls/FAIRS082751.pdf?t.download=true&u=5oefqw.
[7] CVE-2017-5753. 2018. url: https : / / www . cve . org / CVERecord ? id = CVE 2017-5753.
[8] arm Developer. ARM Developer Suite Assembler Guide - Conditional execution. url: https://developer.arm.com/documentation/dui0068/b/ARMInstruction-Reference/Conditional-execution.
[9] Digilent. Nexys A7 Reference. 2022. url: https : / / digilent . com /
reference/programmable-logic/nexys-a7/start.
[10] Digilent. Nexys A7 Reference - Common Anode Circuit Node. 2022. url:
https://digilent.com/reference/_detail/reference/programmablelogic / nexys - a7 / n4t . png ? id = programmable - logic % 3Anexys - a7 %
3Areference-manual.

95

Bibliography
[11]

Git Repository of the EDiC developement. url: https://github.com/NikSch/EDiC.

[12]

Alliance Memory Inc. 512K X 8 BIT LOW POWER CMOS SRAM. 2009.
url: https://www.mouser.de/datasheet/2/12/AS6C4008-1265427.pdf.

[13]

Texas Instruments. CDx4ACT245 Octal-Bus Transceiver, Three-State, NonInverting. 1998. url: https://www.ti.com/lit/ds/symlink/cd74act245.
pdf.

[14]

Texas Instruments. SNx4F245 Octal Bus Transceivers With 3-State Outputs.
1987. url: https://www.ti.com/lit/ds/sdfs010a/sdfs010a.pdf.

[15]

Intel. Intel® 64 and IA-32 Architectures Software Developer’s Manual - Volume 1: Basic Architecture. 2016. url: https://www.intel.com/content/
dam/www/public/us/en/documents/manuals/64-ia-32-architecturessoftware-developer-vol-1-manual.pdf.

[16]

ECMA International. The JSON Data Interchange Syntax. 2017. url: https:
//www.ecma- international.org/wp- content/uploads/ECMA- 404_2nd_
edition_december_2017.pdf.

[17]

William Irwin. THE DIFFERENTIAL ANALYSER EXPLAINED. 2009. url:
http://amg.nzfmm.co.nz/differential_analyser_explained.html.

[18]

MacroMates Ltd. Language Grammars — TextMate 1.x Manual. 2021. url:
https://macromates.com/manual/en/language_grammars.

[19]

Microsoft. TypeScript: JavaScript With Syntax For Types. 2022. url: https:
//www.typescriptlang.org/.

[20]

Microsoft. Visual Studio Code - Code Editing. Redefined. 2022. url: https:
//code.visualstudio.com/.

[21]

MovGP0. TTL NAND with a ”totem-pole” output stage, one of four in 7400.
2006. url: https://en.wikipedia.org/wiki/File:7400_Circuit.svg.

[22]

NandLand. VHDL vs. Verilog - Which language should you use for your FPGA
and ASIC designs? NandLand. 2014. url: https : / / www . nandland . com /
articles/vhdl-or-verilog-for-fpga-asic.html.

[23]

Nolanjshettle. File:Edge triggered D flip flop.svg. 2013. url: https : / / en .
wikipedia.org/wiki/File:Edge_triggered_D_flip_flop.svg.

[24]

David Patterson and John LeRoy Hennessy. Rechnerorganisation und Rechnerentwurf: Die Hardware/Software-Schnittstelle. eng. De Gruyter Studium.
De Gruyter, 2016. isbn: 3110446057.

96

Bibliography
[25] Niklas Schelten. EDiC support for Visual Studio Code. 2022. url: https :
//github.com/Nik-Sch/EDiC-vscode-syntax.
[26] Philips Semiconductors. 74ABT540 Octal buffer, inverting (3-State). 1998.
url: https://www.mouser.com/datasheet/2/302/74ABT540-62406.pdf.
[27] Stunts1990. File:Edge triggered D flip flop with set and reset.svg. 2020. url:
https://en.wikipedia.org/wiki/File:Edge_triggered_D_flip_flop_
with_set_and_reset.svg.
[28] A. M. Turing. “On Computable Numbers, with an Application to the Entscheidungsproblem”. In: Proceedings of the London Mathematical Society s2-42.1
(Jan. 1937), pp. 230–265. issn: 0024-6115. doi: 10.1112/plms/s2-42.1.230.
eprint: https://academic.oup.com/plms/article- pdf/s2- 42/1/230/
4317544/s2- 42- 1- 230.pdf. url: https://doi.org/10.1112/plms/s242.1.230.
[29] Andrew Wylie. The first monolithic integrated circuits. 2013. url: https :
//web.archive.org/web/20180504074623/http://homepages.nildram.
co.uk/~wylie/ICs/monolith.htm.
[30] AMD - Xilinx. Vivado ML Editions - Free Vivado Standard Edition. AMD
- Xilinx. 2022. url: https://www.xilinx.com/products/design- tools/
vivado.html.

Niklas Schelten

97

A Full Schematics of the EDiC

99

A Full Schematics of the EDiC

5

4

3

Control-Signale aus
Microcode-ROM
/ctrlMemPCToRam
/ctrlMemPCFromImm
/ctrlMemPCLoad
/ctrlMemPCEn
/ctrlMeminstrWE
/ctrlMeminstrOE

/ctrlMemPCToRam
/ctrlMemPCFromImm
/ctrlMemPCLoad
/ctrlMemPCEn
/ctrlMeminstrWE
/ctrlMeminstrOE

Sprungadresse aus ROM

D

U48D
74F04
9

H1

8

1
19

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

pcin0
pcin1
pcin2
pcin3
pcin4
pcin5
pcin6
pcin7

/ctrlMemPCEn

9
8

halt

Bisher: U105A

10
U36D
74F08
12

/ctrlMemPCLoad

13
U36C
74F08

DIR
G

10

11 /pcEn

pcin0
pcin1
pcin2
pcin3
pcin4
pcin5
pcin6
pcin7

3
4
5
6
7
8
9
10

clk1

14

L1

11
23
1
2

Bisher: U38B
8

/reset1

/reset1

U50
74F245
instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

2
3
4
5
6
7
8
9

H1

1
19

A0
A1
A2
A3
A4
A5
A6
A7

pcin8
pcin9
pcin10
pcin11
pcin12
pcin13
pcin14
pcin15

H1

/ctrlMemPCFromImm

1
19

CLK

RCO

13

ENT
ENP
S0
S1

pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1

18
17
16
15
14
13
12
11

B0
B1
B2
B3
B4
B5
B6
B7

D0
D1
D2
D3
D4
D5
D6
D7

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

27
22
20

L1

DIR
G

A0
A1
A2
A3
A4
A5
A6
A7

QA
QB
QC
QD
QE
QF
QG
QH

pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

11
12
13
15
16
17
18
19

instrimm_unre
instrimm_unre
instrimm_unre
instrimm_unre
instrimm_unre
instrimm_unre
instrimm_unre
instrimm_unre

11
12
13
15
16
17
18
19

instrimm_unreg8
instrimm_unreg9
instrimm_unreg1
instrimm_unreg1
instrimm_unreg1
instrimm_unreg1
instrimm_unreg1
instrimm_unreg1

11
12
13
15
16
17
18
19

instr_unreg
instr_unreg
instr_unreg
instr_unreg
instr_unreg
instr_unreg
instr_unreg
instr_unreg

WE
OE
CE

U55
74AS867
pcin8
pcin9
pcin10
pcin11
pcin12
pcin13
pcin14
pcin15

3
4
5
6
7
8
9
10

clk1

14

/reset1

11
23
1
2

U51
74F245
2
3
4
5
6
7
8
9

U67
28C256

A
B
C
D
E
F
G
H

22
21
20
19
18
17
16
15

H1
18
17
16
15
14
13
12
11

B0
B1
B2
B3
B4
B5
B6
B7

Rücksprungadresse aus RAM

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

instrROM0

U54
74AS867

U37C
74F32
18
17
16
15
14
13
12
11

9

Mit U48E
zusammengefasst

/ctrlMemPCFromImm

2
3
4
5
6
7
8
9

ProgramCounter

Bisher: U103B

U52
74F245
instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

A
B
C
D
E
F
G
H

QA
QB
QC
QD
QE
QF
QG
QH

CLK

RCO

22
21
20
19
18
17
16
15

pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

13

ENT
ENP
S0
S1

pcin0
pcin1
pcin2
pcin3
pcin4
pcin5
pcin6
pcin7

instrROM1
U69
28C256
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
27
22
20

H1
L1

D0
D1
D2
D3
D4
D5
D6
D7

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14
WE
OE
CE

DIR
G

instrROM1
U62
28C256
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

U49
74F245
C

ram2data0 2
ram2data1 3
ram2data2 4
ram2data3 5
ram2data4 6
ram2data5 7
ram2data6 8
ram2data7 9
H1

1
19

A0
A1
A2
A3
A4
A5
A6
A7

18
17
16
15
14
13
12
11

B0
B1
B2
B3
B4
B5
B6
B7

pcin8
pcin9
pcin10
pcin11
pcin12
pcin13
pcin14
pcin15

DIR
G

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

27
22
20

H1
L1

D0
D1
D2
D3
D4
D5
D6
D7

WE
OE
CE

U99
74F245
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

2
3
4
5
6
7
8
9
H1

/ctrlMemPCToRam

1
19

2
3
4
5
6
7
8
9

1

18 bus0
17 bus1
16 bus2
15 bus3
14 bus4
13 bus5
12 bus6
11 bus7

DIR
G

RN32
8X10K
ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

B0
B1
B2
B3
B4
B5
B6
B7

A0
A1
A2
A3
A4
A5
A6
A7

U98
74F245

VCC
pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

2
3
4
5
6
7
8
9
H1

/ctrlMemPCToRam

B0
B1
B2
B3
B4
B5
B6
B7

A0
A1
A2
A3
A4
A5
A6
A7

1
19

18
17
16
15
14
13
12
11

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

3
5
7
9
12
14
16
18

brkpt0
brkpt1
brkpt2
brkpt3
brkpt4
brkpt5
brkpt6
brkpt7

DIR
G

B

Breakpoint
U53
74F521

Von Clock-Generator
/breakpointEnable

/breakpointEnable

1
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

G

2
4
6
8
11
13
15
17

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

19

U60
74F521
RN1
8X10K
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

1

2
3
4
5
6
7
8
9

1

pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

VCC

G

2
4
6
8
11
13
15
17

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

brkpt8
brkpt9
brkpt10
brkpt11
brkpt12
brkpt13
brkpt14
brkpt15

3
5
7
9
12
14
16
18
19

/breakpointHit

U1
74ABT540

A

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

2
3
4
5
6
7
8
9

L1
L1

1
19

A1
A2
A3
A4
A5
A6
A7
A8

Anzeigen zum Debuggen

RN2
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_bus0
LED_bus1
LED_bus2
LED_bus3
LED_bus4
LED_bus5
LED_bus6
LED_bus7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

U57
74ABT540
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

2
3
4
5
6
7
8
9
1
19

L1
L1

G1
G2

A1
A2
A3
A4
A5
A6
A7
A8

Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_p
LED_p
LED_p
LED_p
LED_p
LED_p
LED_p
LED_p

18
17
16
15
14
13
12
11

LED_p
LED_p
LED_p
LED_p
LED_p
LED_p
LED_p
LED_p

G1
G2

U58
74ABT540
pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

Systemsignale
clk1
/reset1
halt

clk1
/reset1
halt

1
19

L1
L1

5

4

Figure A.1: Schematic: Program Counter / Instruction ROM.
100

2
3
4
5
6
7
8
9

3

A1
A2
A3
A4
A5
A6
A7
A8
G1
G2

Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

3

2

1

Datenbus

instrROM0

Instruction Register

U67
28C256
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
27
22
20

H1
L1

pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

instrimm_unreg0_src
instrimm_unreg1_src
instrimm_unreg2_src
instrimm_unreg3_src
instrimm_unreg4_src
instrimm_unreg5_src
instrimm_unreg6_src
instrimm_unreg7_src

11
12
13
15
16
17
18
19

Konstante zu Bus

U70
74F825

Test
D0
D1
D2
D3
D4
D5
D6
D7

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

instrimm_unreg0
instrimm_unreg1
instrimm_unreg2
instrimm_unreg3
instrimm_unreg4
instrimm_unreg5
instrimm_unreg6
instrimm_unreg7

3
4
5
6
7
8
9
10
clk1
13
/ctrlMeminstrWE 14
/reset1
11

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

U75
74F245

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

22
21
20
19
18
17
16
15
1
2
23

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

2
3
4
5
6
7
8
9

H1

1
19

/ctrlMeminstrOE

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

18
17
16
15
14
13
12
11

D

Immediate

DIR
G

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

L1

WE
OE
CE

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

instrROM1
U69
28C256
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
27
22
20

H1
L1

U71
74F825
D0
D1
D2
D3
D4
D5
D6
D7

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

instrimm_unreg8_src
instrimm_unreg9_src
instrimm_unreg10_src
instrimm_unreg11_src
instrimm_unreg12_src
instrimm_unreg13_src
instrimm_unreg14_src
instrimm_unreg15_src

11
12
13
15
16
17
18
19

instrimm_unreg8
instrimm_unreg9
instrimm_unreg10
instrimm_unreg11
instrimm_unreg12
instrimm_unreg13
instrimm_unreg14
instrimm_unreg15

3
4
5
6
7
8
9
10
clk1
13
/ctrlMeminstrWE 14
/reset1
11

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

22
21
20
19
18
17
16
15
1
2
23

U110
74ABT540
instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

L1

L1 1
L1 19

WE
OE
CE

U62
28C256
10
9
8
7
6
5
4
3
25
24
21
23
2
26
1

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

27
22
20

H1
L1

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

U64
74F825
D0
D1
D2
D3
D4
D5
D6
D7

instr_unreg0_src
instr_unreg1_src
instr_unreg2_src
instr_unreg3_src
instr_unreg4_src
instr_unreg5_src
instr_unreg6_src
instr_unreg7_src

11
12
13
15
16
17
18
19

instr_unreg0
instr_unreg1
instr_unreg2
instr_unreg3
instr_unreg4
instr_unreg5
instr_unreg6
instr_unreg7

3
4
5
6
7
8
9
10
clk1
13
/ctrlMeminstrWE 14
/reset1
11

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

22
21
20
19
18
17
16
15
1
2
23

H1

/ctrlMemPCToRam

1
19

RN29
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_imm0
LED_imm1
LED_imm2
LED_imm3
LED_imm4
LED_imm5
LED_imm6
LED_imm7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

18
17
16
15
14
13
12
11

LED_imm8
LED_imm9
LED_imm10
LED_imm11
LED_imm12
LED_imm13
LED_imm14
LED_imm15

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

1

VCC

G1
G2

A1
A2
A3
A4
A5
A6
A7
A8

RN30
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

G1
G2

Instruction
U112
74ABT540

B0
B1
B2
B3
B4
B5
B6
B7

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

L1

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

A0
A1
A2
A3
A4
A5
A6
A7

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

C

WE
OE
CE

2
3
4
5
6
7
8
9

2
3
4
5
6
7
8
9
L1 1
L1 19

U99
74F245
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

A1
A2
A3
A4
A5
A6
A7
A8

U111
74ABT540

instrROM1

pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7
pc8
pc9
pc10
pc11
pc12
pc13
pc14

2
3
4
5
6
7
8
9

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

2
3
4
5
6
7
8
9
L1 1
L1 19

18 bus0
17 bus1
16 bus2
15 bus3
14 bus4
13 bus5
12 bus6
11 bus7

A1
A2
A3
A4
A5
A6
A7
A8

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

RN31
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

LED_inst0
LED_inst1
LED_inst2
LED_inst3
LED_inst4
LED_inst5
LED_inst6
LED_inst7

18
17
16
15
14
13
12
11

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

G1
G2

DIR
G

U98
74F245
pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

2
3
4
5
6
7
8
9
H1

/ctrlMemPCToRam

B0
B1
B2
B3
B4
B5
B6
B7

A0
A1
A2
A3
A4
A5
A6
A7

1
19

18
17
16
15
14
13
12
11

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

Von / zu RAM 2
ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

DIR
G

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

B

Zu Clock-Generator

Breakpoint

Bedienelemente zum Debuggen

U53
74F521

SW8
1
pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

RN7
8X10KSIL9

G

2
4
6
8
11
13
15
17

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

brkpt0
brkpt1
brkpt2
brkpt3
brkpt4
brkpt5
brkpt6
brkpt7

3
5
7
9
12
14
16
18

brkpt0
brkpt1
brkpt2
brkpt3
brkpt4
brkpt5
brkpt6
brkpt7

2
3
4
5
6
7
8
9

1

VCC

brkpt0
brkpt1
brkpt2
brkpt3

1
4
3
6

brkpt4
brkpt5
brkpt6
brkpt7

1
4
3
6

19

/breakpointHit

PT65-106

A
B
C COM2
D COM1
A
B
C COM2
D COM1

5
2

instrimm_unreg0_src
instrimm_unreg1_src
instrimm_unreg2_src
instrimm_unreg3_src
instrimm_unreg4_src
instrimm_unreg5_src
instrimm_unreg6_src
instrimm_unreg7_src
instrimm_unreg8_src
instrimm_unreg9_src
instrimm_unreg10_src
instrimm_unreg11_src
instrimm_unreg12_src
instrimm_unreg13_src
instrimm_unreg14_src
instrimm_unreg15_src

5
2

SW7

PT65-106

SW6

PT65-106

U60
74F521
1
pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

RN6
8X10KSIL9

G

2
4
6
8
11
13
15
17

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

brkpt8
brkpt9
brkpt10
brkpt11
brkpt12
brkpt13
brkpt14
brkpt15

3
5
7
9
12
14
16
18

brkpt8
brkpt9
brkpt10
brkpt11
brkpt12
brkpt13
brkpt14
brkpt15

2
3
4
5
6
7
8
9

1

VCC

brkpt8
brkpt9
brkpt10
brkpt11

1
4
3
6

brkpt12
brkpt13
brkpt14
brkpt15

1
4
3
6

A
B
C COM2
D COM1
A
B
C COM2
D COM1
SW5

19

JT1
BERG40

Test

5
2

1
3
5
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
39

5
2

JT2
BERG26

U57
74ABT540
2
3
4
5
6
7
8
9
1
19

L1
L1

A1
A2
A3
A4
A5
A6
A7
A8

Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

LED_pc0
LED_pc1
LED_pc2
LED_pc3
LED_pc4
LED_pc5
LED_pc6
LED_pc7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

2
3
4
5
6
7
8
9
1
19

L1
L1

1

VCC

1
3
5
7
9
11
13
15
17
19
21
23
25

G1
G2

A1
A2
A3
A4
A5
A6
A7
A8

2
4
6
8
10
12
14
16
18
20
22
24
26

instr_unreg0
instr_unreg1
instr_unreg2
instr_unreg3
instr_unreg4
instr_unreg5
instr_unreg6
instr_unreg7

A

JT3
BERG26

U58
74ABT540
pc8
pc9
pc10
pc11
pc12
pc13
pc14
pc15

instr_unreg0_src
instr_unreg1_src
instr_unreg2_src
instr_unreg3_src
instr_unreg4_src
instr_unreg5_src
instr_unreg6_src
instr_unreg7_src

RN8
8X220R
18
17
16
15
14
13
12
11

instrimm_unreg0
instrimm_unreg1
instrimm_unreg2
instrimm_unreg3
instrimm_unreg4
instrimm_unreg5
instrimm_unreg6
instrimm_unreg7
instrimm_unreg8
instrimm_unreg9
instrimm_unreg10
instrimm_unreg11
instrimm_unreg12
instrimm_unreg13
instrimm_unreg14
instrimm_unreg15

PT65-106

/breakpointHit

pc0
pc1
pc2
pc3
pc4
pc5
pc6
pc7

2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40

bus0
bus2
bus4
bus6
ram2data0
ram2data2
ram2data4
ram2data6

RN9
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_pc8
LED_pc9
LED_pc10
LED_pc11
LED_pc12
LED_pc13
LED_pc14
LED_pc15

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

G1
G2

1
3
5
7
9
11
13
15
17
19
21
23
25

2
4
6
8
10
12
14
16
18
20
22
24
26

bus1
bus3
bus5
bus7
ram2data1
ram2data3
ram2data5
ram2data7

TIGRIS Elektronik GmbH
Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title

EDIC

3

2

Niklas Schelten

Size
A1

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

Program Counter / Instruction ROM
Rev
see title
Sheet

2

of

10

1

101

A Full Schematics of the EDiC

5

4

3

Memory Adress Register
U68
74F825

Datenbus
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

3
4
5
6
7
8
9
10

clk1
/ctrlMemMar1WE
/reset1

13
14
11

D

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

22
21
20
19
18
17
16
15

mar8
mar9
mar10
mar11
mar12
mar13
mar14
mar15

1
2
23

L2

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

3
4
5
6
7
8
9
10

clk1

13
14
11

/ctrlMemMar0WE
/reset1
ctrlMeminstrimmToRamAddr

Multiplexer für Adressdecodierung
U73
74F245
mar8
mar9
mar10
mar11
mar12
mar13
mar14
mar15

2
3
4
5
6
7
8
9
H2

ctrlMeminstrimmToRamAddr

1
19

Immediate-Adresse
aus Instruction-ROM
instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7
instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

A0
A1
A2
A3
A4
A5
A6
A7

RN21
8X10KSIL9
B0
B1
B2
B3
B4
B5
B6
B7

18
17
16
15
14
13
12
11

select0
select1
select2
select3
select4
select5
select6
select7

18
17
16
15
14
13
12
11

select0
select1
select2
select3
select4
select5
select6
select7

select0
select1
select2
select3
select4
select5
select6
select7

2
3
4
5
6
7
8
9

1

VCC

VCC

1

VCC

1

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

2
3
4
5
6
7
8
9

H2

1
19

DIR
G

U74
74F245

instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15
U48A
74F04

instrimm8
instrimm9
instrimm10
instrimm11
instrimm12
instrimm13
instrimm14
instrimm15

1

2

2
3
4
5
6
7
8
9
H2

/instrimm1Select

1
19

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

Decodierung I/O

DIR
G

U79
74F521
L2
select0
select1
select2
select3
select4
select5
select6
select7

1
2
4
6
8
11
13
15
17

G
A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

C

A=B

3
5
7
9
12
14
16
18

L2
H2

Test
/ioCE_src

/ioCE

/ramCE_src

/ramCE

19
U48B
74F04
3

4

Bisher: U80A

Decodierung Stack
U76
74F521
L2
select0
select1
select2
select3
select4
select5
select6
select7

1
2
4
6
8
11
13
15
17

G
A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

3
5
7
9
12
14
16
18

H2

19 /selectStackMem_src

Test
/selectStackMem

instrimm8 2
instrimm9 3
instrimm10 4
instrimm11 5
instrimm12 6
instrimm13 7
instrimm14 8
instrimm15 9

U38D
74F08

U48C
74F04

13
B

ctrlMeminstrimmToRamAddr

11 5

6

H2

/instrImm1ToRam

1
19

12

mar8
mar9
mar10
mar11
mar12
mar13
mar14
mar15

U38C
74F08

U48F
74F04

10
8 13

12

/mar1ToRam

2
3
4
5
6
7
8
9
H2

1
19

9

U107
74ABT540
mar8
mar9
mar10
mar11
mar12
mar13
mar14
mar15

2
3
4
5
6
7
8
9
L2 1
L2 19

A1
A2
A3
A4
A5
A6
A7
A8

RN26
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_mar0
LED_mar1
LED_mar2
LED_mar3
LED_mar4
LED_mar5
LED_mar6
LED_mar7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

Stack Pointer
VCC

U56
74AS867

G1
G2

Bisher: U103A

L2
clk1

U37D
74F32
/ctrlMemSPEn 12
halt

3
4
5
6
7
8
9
10

11 /spEn
/reset1

13

14
L2

11
23
1
2

/spToRam

A
B
C
D
E
F
G
H

QA
QB
QC
QD
QE
QF
QG
QH

CLK

RCO

22 sp0
21 sp1
20 sp2
19 sp3
18 sp4
17 sp5
16 sp6
15 sp7

H2

1
19

sp0
sp1
sp2
sp3
sp4
sp5
sp6
sp7

2
3
4
5
6
7
8
9

sp0
sp1
sp2
sp3
sp4
sp5
sp6
sp7

2
3
4
5
6
7
8
9

13

ENT
ENP
S0
S1

U38A
74F08

Control-Signale aus
Microcode-ROM

ctrlMemSPUp

1

/reset1

2

3

A

/ctrlMemPCToRAM
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemSPEn
ctrlMemSPUp
/ctrlMemRamWE
/ctrlMemRamOE

/ctrlMemPCToRAM
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemSPEn
ctrlMemSPUp
/ctrlMemRamWE
/ctrlMemRamOE

L2 1
L2 19

Systemsignale
clk1
/reset1
halt

clk1
/reset1
halt

5

4

Figure A.2: Schematic: RAM.
102

3

3

2

1

Zu Schaltungsteil I/O
/ioCE

CMOS-Buffer
U63
74F825
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

3
4
5
6
7
8
9
10

clk1

13
14
11

Mar0WE
/reset1

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

U201
74ACT245

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

22 ramAddress0
21 ramAddress1
20 ramAddress2
19 ramAddress3
18 ramAddress4
17 ramAddress5
16 ramAddress6
15 ramAddress7
1
2
23

2
3
4
5
6
7
8
9

/ctrlMemRamOE

A0
A1
A2
A3
A4
A5
A6
A7

1

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

18
17
16
15
14
13
12
11

B0
B1
B2
B3
B4
B5
B6
B7

DIR
G

L2 19

gepufferte Signale
(CMOS-Pegel)
für I/O-Schnittstelle

L2

strimmToRamAddr

U202
74ACT245

RN22
8X10KSIL9
VCC

1

2
3
4
5
6
7
8
9

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

2
3
4
5
6
7
8
9

A0
A1
A2
A3
A4
A5
A6
A7

H2 1
L2 19

1

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

RN24
8X10KSIL9
B0
B1
B2
B3
B4
B5
B6
B7

18
17
16
15
14
13
12
11

ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7

18
17
16
15
14
13
12
11

ramAddress_buf8
ramAddress_buf9
ramAddress_buf10
ramAddress_buf11
ramAddress_buf12
ramAddress_buf13
ramAddress_buf14
ramAddress_buf15

1

VCC

2
3
4
5
6
7
8
9

D

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

DIR
G

U203
74ACT245

RN23
8X10KSIL9
VCC

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

2
3
4
5
6
7
8
9

ramAddress8
ramAddress9
ramAddress10
ramAddress11
ramAddress12
ramAddress13
ramAddress14
ramAddress15

ramAddress8
ramAddress9
ramAddress10
ramAddress11
ramAddress12
ramAddress13
ramAddress14
ramAddress15

2
3
4
5
6
7
8
9

A0
A1
A2
A3
A4
A5
A6
A7

H2 1
L2 19

B0
B1
B2
B3
B4
B5
B6
B7

DIR
G
ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7

ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7

C

U204
74ACT245
/reset1
clk1

9
8
7
6
5
4
3
2

/ctrlMemRamWE
/ctrlMemRamOE
U48E
74F04

U65
74F245
instrimm0
instrimm1
instrimm2
instrimm3
instrimm4
instrimm5
instrimm6
instrimm7

2
3
4
5
6
7
8
9

H2

1
19

A0
A1
A2
A3
A4
A5
A6
A7

/ctrlMemPCToRAM 11
B0
B1
B2
B3
B4
B5
B6
B7

18 ramAddress0
17 ramAddress1
16 ramAddress2
15 ramAddress3
14 ramAddress4
13 ramAddress5
12 ramAddress6
11 ramAddress7

10

H2
L2

1
19

A7
A6
A5
A4
A3
A2
A1
A0

R239
0R0
B7
B6
B5
B4
B3
B2
B1
B0

11
12
13
14
15
16
17
18

/reset_buf
clk_buf
/ioCE_buf

clk_buf
/ioCE_buf

DIR
G

RAM
U77
AS6C4008

Bisher: U80B
ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7
ramAddress_buf8
ramAddress_buf9
ramAddress_buf10
ramAddress_buf11
ramAddress_buf12
ramAddress_buf13
ramAddress_buf14
ramAddress_buf15

DIR
G
U66
74F245

instrimm8 2
instrimm9 3
instrimm10 4
instrimm11 5
instrimm12 6
instrimm13 7
instrimm14 8
instrimm15 9

U38D
74F08

U48C
74F04

13
strimmToRamAddr

11 5

6

H2

/instrImm1ToRam

1
19

12

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

18 ramAddress8
17 ramAddress9
16 ramAddress10
15 ramAddress11
14 ramAddress12
13 ramAddress13
12 ramAddress14
11 ramAddress15

12
11
10
9
8
7
6
5
27
26
23
25
4
28
3
31
2
30
1

selectStackMem_buf
L2
L2

DIR
G

/ctrlMemRamWE_buf
/ctrlMemRamOE_buf

29
24

/ramCE_buf

22

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14
A15
A16
A17
A18

D0
D1
D2
D3
D4
D5
D6
D7

13
14
15
17
18
19
20
21

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

#WE
#OE

B

#CE
/ctrlMemRamWE_buf
/ctrlMemRamOE_buf

/ctrlMemRamWE_buf
/ctrlMemRamOE_buf

U72
74F245
mar8
mar9
mar10
mar11
mar12
mar13
mar14
mar15

U38C
74F08

U48F
74F04

10
8 13

12

/mar1ToRam

2
3
4
5
6
7
8
9
H2

1
19

9

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

18 ramAddress8
17 ramAddress9
16 ramAddress10
15 ramAddress11
14 ramAddress12
13 ramAddress13
12 ramAddress14
11 ramAddress15

ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7
ramAddress_buf8
ramAddress_buf9
ramAddress_buf10
ramAddress_buf11
ramAddress_buf12
ramAddress_buf13
ramAddress_buf14
ramAddress_buf15

DIR
G

U61
74F245

ointer
U56
74AS867

her: U103A
U37D
74F32
12

L2

3
4
5
6
7
8
9
10

clk1

14

11 /spEn
/reset1

13

L2

11
23
1
2

/spToRam

A
B
C
D
E
F
G
H

QA
QB
QC
QD
QE
QF
QG
QH

CLK

RCO

22 sp0
21 sp1
20 sp2
19 sp3
18 sp4
17 sp5
16 sp6
15 sp7

H2

1
19

sp0
sp1
sp2
sp3
sp4
sp5
sp6
sp7

2
3
4
5
6
7
8
9

sp0
sp1
sp2
sp3
sp4
sp5
sp6
sp7

2
3
4
5
6
7
8
9

DIR
G
A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

RN33
8X10K

RAM2
ram2d0
ram2d1
ram2d2
ram2d3
ram2d4
ram2d5
ram2d6
ram2d7

U100
AS6C4008
12
11
10
9
8
7
6
5
27
26
23
25
4
28
3
31
2
30
1

L2
L2

18 ramAddress8
17 ramAddress9
16 ramAddress10
15 ramAddress11
14 ramAddress12
13 ramAddress13
12 ramAddress14
11 ramAddress15

29
24
22

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14
A15
A16
A17
A18

2
3
4
5
6
7
8
9

1

VCC

Von / zu
Schaltungsteil
Control

U205
74ACT245
D0
D1
D2
D3
D4
D5
D6
D7

13
14
15
17
18
19
20
21

ram2d0 18
ram2d1 17
ram2d2 16
ram2d3 15
ram2d4 14
ram2d5 13
ram2d6 12
ram2d7 11

ram2d0
ram2d1
ram2d2
ram2d3
ram2d4
ram2d5
ram2d6
ram2d7

B0
B1
B2
B3
B4
B5
B6
B7

A0
A1
A2
A3
A4
A5
A6
A7
DIR
G

2
3
4
5
6
7
8
9

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

ram2data0
ram2data1
ram2data2
ram2data3
ram2data4
ram2data5
ram2data6
ram2data7

1
19 L2

#WE
#OE
#CE

13

ENT
ENP
S0
S1

U38A
74F08

U106
74ABT540

1
3
2

L2 1
L2 19

A1
A2
A3
A4
A5
A6
A7
A8

RN25
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_sp0
LED_sp1
LED_sp2
LED_sp3
LED_sp4
LED_sp5
LED_sp6
LED_sp7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

G1
G2

U108
74ABT540
1

VCC

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

2
3
4
5
6
7
8
9

L2 1
L2 19

A1
A2
A3
A4
A5
A6
A7
A8

RN27
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_ra0
LED_ra1
LED_ra2
LED_ra3
LED_ra4
LED_ra5
LED_ra6
LED_ra7

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

2
3
4
5
6
7
8
9

L2 1
L2 19

3

Änderungen:

A1
A2
A3
A4
A5
A6
A7
A8
G1
G2

A

Pull-Up an select7..0
Pull-Up an ramAddress 15..0

G1
G2

2

Niklas Schelten

VCC

CMOS-Buffer für RAM und I/O

U109
74ABT540
ramAddress8
ramAddress9
ramAddress10
ramAddress11
ramAddress12
ramAddress13
ramAddress14
ramAddress15

1

RN28
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_ra8
LED_ra9
LED_ra10
LED_ra11
LED_ra12
LED_ra13
LED_ra14
LED_ra15

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

/ioCE_src
/ramCE_src
/selectStackMem_src

TIGRIS Elektronik GmbH

JT4
BERG10

Test
1
3
5
7
9

2
4
6
8
10

Teltowkanalstr.2
12247 Berlin
/ioCE
/ramCE
/selectStackMem

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title

EDIC
Size
A1

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

RAM
Rev
see title
Sheet

3

of

10

1

103

A Full Schematics of the EDiC

5

4

3

Flags von ALU
flagNegative
flagZero
flagCarry
flagOverflow

U83
74F825

flagNegative
flagZero
flagCarry
flagOverflow

U81B
74F86
H1
mc_a0

flagNegative
flagZero
flagCarry
flagOverflow

U59A
74F08

4
6

1

5

3

H3

/ctrlinstrFinished 2
U81D
74F86

Von Clock-Generator
D

mc_a0

halt

halt

11

mc_a1

clk1
halt
/reset1

U59B
74F08

12

3
4
5
6
7
8
9
10
13
14
11

4

13

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

22
21
20
19
18
17
16
15
1
2
23
L3

6
/ctrlinstrFinished 5

U59D
74F08
mc_a0

12

mc_a1

13

U81C
74F86
11

U59C
74F08

10
8

9

9

8
/ctrlinstrFinished 10

mc_a2

Von Instruction-ROM

C

U84
74F374

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

3
4
7
8
13
14
17
18

clk1

11
L3

D0
D1
D2
D3
D4
D5
D6
D7
CLK

1

OE

Systemsignale
clk1
/reset1

clk1
/reset1

B

Test
JT5
BERG40
1
3
/ctrlAluYWE_src
5
/ctrlAluOE_src
7
/ctrlReg0WE_src
9
/ctrlReg1WE_src
11
ctrlRegAluSel_src
13
/ctrlReg0BusOE_src
15
/ctrlReg1BusOE_src
17
/ctrlMemPCLoad_src
19
ctrlMemSPUp_src
21
/ctrlMemSPEn_src
23
/ctrlMemInstrWE_src
25
/ctrlMemInstrOE_src
27
/ctrlMemMar0WE_src
29
/ctrlMemMar1WE_src
31
ctrlMeminstrimmToRamAddr_src 33
/ctrlMemRamWE_src
35
37
39

2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40

/ctrlAluYWE
/ctrlAluOE
/ctrlReg0WE
/ctrlReg1WE
ctrlRegAluSel
/ctrlReg0BusOE
/ctrlReg1BusOE
/ctrlMemPCLoad
ctrlMemSPUp
/ctrlMemSPEn
/ctrlMemInstrWE
/ctrlMemInstrOE
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemRamWE

JT6
BERG26
A

/ctrlMemRamOE_src
/ctrlMemPCEn_src
/ctrlMemPCFromImm_src
/ctrlMemPCToRam_src
/ctrlinstrFinished_src
ctrlAluSub_src
ctrlAluOp0_src
ctrlAluOp1_src

5

1
3
5
7
9
11
13
15
17
19
21
23
25

2
4
6
8
10
12
14
16
18
20
22
24
26

/ctrlMemRamOE
/ctrlMemPCEn
/ctrlMemPCFromImm
/ctrlMemPCToRam
/ctrlinstrFinished
ctrlAluSub
ctrlAluOp0
ctrlAluOp1

4

Figure A.3: Schematic: Microcode.
104

3

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

2
5
6
9
12
15
16
19

3

2

1

U83
74F825
flagNegative
flagZero
flagCarry
flagOverflow
H3

clk1
halt
/reset1

3
4
5
6
7
8
9
10
13
14
11

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

22
21
20
19
18
17
16
15

mc_a11
mc_a12
mc_a13
mc_a14
mc_a0
mc_a1
mc_a2

1
2
23

D

L3

U96
74ABT540
mc_a11
mc_a12
mc_a13
mc_a14

U84
74F374
instr0
instr1
instr2
instr3
instr4
instr5
instr6
instr7

3
4
7
8
13
14
17
18

clk1

11
L3

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

2
5
6
9
12
15
16
19

mc_a3
mc_a4
mc_a5
mc_a6
mc_a7
mc_a8
mc_a9
mc_a10

mc_a0
mc_a1
mc_a2

2
3
4
5
6
7
8
9

L3

L3
L3

1
19

A1
A2
A3
A4
A5
A6
A7
A8

RN11
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_f_N1
LED_f_Z1
LED_f_C1
LED_f_O1

LED
LED
LED
LED

LED_a0
LED_a1
LED_a2

LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

C

G1
G2

CLK

1

OE

Microcode ROM
U85
28C256
mc_a0
mc_a1
mc_a2
mc_a3
mc_a4
mc_a5
mc_a6
mc_a7
mc_a8
mc_a9
mc_a10
mc_a11
mc_a12
mc_a13
mc_a14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
H3
L3

27
22
20

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

Test
D0
D1
D2
D3
D4
D5
D6
D7

11 /ctrlAluYWE_src
12 /ctrlAluOE_src
13 /ctrlReg0WE_src
15 /ctrlReg1WE_src
16 ctrlRegAluSel_src
17 /ctrlReg0BusOE_src
18 /ctrlReg1BusOE_src
19 /ctrlMemPCLoad_src

/ctrlAluYWE
/ctrlAluOE
/ctrlReg0WE
/ctrlReg1WE
ctrlRegAluSel
/ctrlReg0BusOE
/ctrlReg1BusOE
/ctrlMemPCLoad

11 ctrlMemSPUp_src
12 /ctrlMemSPEn_src
13 /ctrlMemInstrWE_src
15 /ctrlMemInstrOE_src
16 /ctrlMemMar0WE_src
17 /ctrlMemMar1WE_src
18 ctrlMeminstrimmToRamAddr_src
19 /ctrlMemRamWE_src

ctrlMemSPUp
/ctrlMemSPEn
/ctrlMemInstrWE
/ctrlMemInstrOE
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemRamWE

WE
OE
CE

U86
28C256
mc_a0
mc_a1
mc_a2
mc_a3
mc_a4
mc_a5
mc_a6
mc_a7
mc_a8
mc_a9
mc_a10
mc_a11
mc_a12
mc_a13
mc_a14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
H3
L3

27
22
20

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

D0
D1
D2
D3
D4
D5
D6
D7

B

Control-Signale
/ctrlAluYWE
/ctrlAluOE
/ctrlReg0WE
/ctrlReg1WE
ctrlRegAluSel
/ctrlReg0BusOE
/ctrlReg1BusOE
/ctrlMemPCLoad

WE
OE
CE

ctrlMemSPUp
/ctrlMemSPEn
/ctrlMemInstrWE
/ctrlMemInstrOE
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemRamWE

U87
28C256
mc_a0
mc_a1
mc_a2
mc_a3
mc_a4
mc_a5
mc_a6
mc_a7
mc_a8
mc_a9
mc_a10
mc_a11
mc_a12
mc_a13
mc_a14

10
9
8
7
6
5
4
3
25
24
21
23
2
26
1
H3
L3

27
22
20

A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
A10
A11
A12
A13
A14

D0
D1
D2
D3
D4
D5
D6
D7

/ctrlMemRamOE
/ctrlMemPCEn
/ctrlMemPCFromImm
/ctrlMemPCToRam
/ctrlinstrFinished

11 /ctrlMemRamOE_src
12 /ctrlMemPCEn_src
13 /ctrlMemPCFromImm_src
15 /ctrlMemPCToRam_src
16 /ctrlinstrFinished_src
17
18
19

/ctrlMemRamOE
/ctrlMemPCEn
/ctrlMemPCFromImm
/ctrlMemPCToRam
/ctrlinstrFinished

ctrlAluSub
ctrlAluOp0
ctrlAluOp1

/ctrlAluYWE
/ctrlAluOE
/ctrlReg0WE
/ctrlReg1WE
ctrlRegAluSel
/ctrlReg0BusOE
/ctrlReg1BusOE
/ctrlMemPCLoad
ctrlMemSPUp
/ctrlMemSPEn
/ctrlMemInstrWE
/ctrlMemInstrOE
/ctrlMemMar0WE
/ctrlMemMar1WE
ctrlMeminstrimmToRamAddr
/ctrlMemRamWE
/ctrlMemRamOE
/ctrlMemPCEn
/ctrlMemPCFromImm
/ctrlMemPCToRam
/ctrlinstrFinished

ctrlAluSub
ctrlAluOp0
ctrlAluOp1
A

WE
OE
CE

TIGRIS Elektronik GmbH
mc_a3
mc_a4
mc_a5

R21
R22
R23

0R0
0R0
0R0

ctrlAluSub
ctrlAluOp0
ctrlAluOp1

ctrlAluSub_src
ctrlAluOp0_src
ctrlAluOp1_src

Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title
Microcode ROM

EDIC

3

2

Niklas Schelten

Size
A2

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

Rev
see title
Sheet

4

of

10

1

105

A Full Schematics of the EDiC

5

4

Bedienelemente zum Debuggen

3

VCC

Zu/von Program Counter/Instr-ROM

Bisher: 74HCT14
SW1
SW
Breakpoint Enable

R1
10K

U33A
74ACT14
1

21
R5
100K

Geschlossen: Normalbetrieb (Breakpoint unwirksam)
Offen: Breakpoint wirksam

/breakpointEnable

2

Vergleichsschaltung für
Programmspeicher-Adresse

/breakpointEnable

/breakpointHit

/breakpointHit

C1
100nF

D

VCC

U36A
74F08

U33E
74ACT14
SW2
TA

R2
10K

U33B
74ACT14

1

Step
3

debug_step

4

D

Q

rq1

rd2

D

rq2

Q

rd3

2
D

Q

rq3

11

10

Taste gedrückt = Step
R6
100K

C2
100nF

Bisher: U233E, 74F04

Logik für Waitstaes und Break

Von Microcode-ROM
/ctrlInstrFinished

/ctrlInstrFinished

VCC
C

SW3
SW
Instr/Cycle

R3
10K

U33C
74ACT14
5

21
R7
100K

Geschlossen: 1 Step = 1 Instruktion
Offen: 1 Step = 1 Takt

6

debug_instr_/#cycle

D

Q

rq5

rd6

D

Q

rq6

8

debug_step/#run

D

Q

rq7

rd8

D

Q

rq8

C3
100nF

VCC

SW4
Step/Run

R4
10K

U33D
74ACT14
9

21

Geschlossen: Step-Betrieb
Offen = Normalbetrieb (durchlaufend)

SW

R8
100K

C4
100nF

B

Power-On-Reset
VCC

2

VCC

R231
10K

VCC

U34
DS1813-10

1

clk1

Buffer

GND

/RST

U95
74ABT245

3

SW1301
TA
Reset

9
8
7
6
5
4
3
2

Taste gedrückt = Reset

Taktgenerator

VCC

14
11

Test

X1
XOS_tbd_MHz
VCC CLK 8

clk_unbuf_src

clk_unbuf

VCC
GND

H3
L3

7

1
19

A7
A6
A5
A4
A3
A2
A1
A0

Systemsignale
B7
B6
B5
B4
B3
B2
B1
B0

11
12
13
14
15
16
17
18

R232
R233
R234
R235
R236
R237
R238

/reset1
clk1

0R0
0R0
0R0
0R0
0R0
0R0
0R0

DIR
G

A

5

4

Figure A.4: Schematic: Clock and Reset.
106

3

/reset1
clk1

3

2

1

er/Instr-ROM

ür
dresse

d3

2
3
4
5
6
7
8

/breakpointHit

/breakpointHit

D

cycle
U36A
74F08

U33E
74ACT14

Statemachine für das
Steppen von
Befehlszyklen

1
3
2
D

Q

rq3

11

10

U37A
74F32

Bisher: U233E, 74F04

instr
U36B
74F08

1
3

U37B
74F32

2
4
6

4

5

rd4

6

D

Q

rq4

5

Von Microcode-ROM
/ctrlInstrFinished

Zu Microcode-Steuerung

/ctrlInstrFinished

/ctrlInstrFinished

U39
74F151

U33F
74ACT14
13

12
H3
H3
H3
H3

Bisher: U233F, 74F04
rq6

4
3
2
1
15
14
13
12

L3

11
10
9

L3

7

D0
D1
D2
D3
D4
D5
D6
D7

Stack Pointer

Test
Y
Y

5
6

Program Counter
halt_src

halt

halt
C

A
B
C
G

rq8
U35
74F273
debug_step
rd2
rd3
rd4
debug_instr_/#cycle
rd6
debug_step/#run
rd8

3
4
7
8
13
14
17
18

clk1

11

/reset1

1

D1
D2
D3
D4
D5
D6
D7
D8

Q1
Q2
Q3
Q4
Q5
Q6
Q7
Q8

2
5
6
9
12
15
16
19

rq1
rq2
rq3
rq4
rq5
rq6
rq7
rq8

CLK
CLR

B

clk1

Systemsignale
/reset1
clk1

0R0
0R0
0R0
0R0
0R0
0R0
0R0

/reset1
clk1

A

clk_unbuf_src
halt_src

3

2

Niklas Schelten

TIGRIS Elektronik GmbH

JT7
BERG10

Test
1
3
5
7
9

2
4
6
8
10

clk_unbuf
halt

Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title
Clock und Reset

EDIC
Size
A2

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

Rev
see title
Sheet

5

of

10

1

107

A Full Schematics of the EDiC

5

4

3

Von Schaltungsteil RAM
/ioCE

/ioCE

U88
74F521
1

D

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

ramAddress0
ramAddress1
ramAddress2
ramAddress3
ramAddress4
ramAddress5
ramAddress6
ramAddress7

2
4
6
8
11
13
15
17

G
A0
A1
A2
A3
A4
A5
A6
A7

3
5
7
9
12
14
16
18

B0
B1
B2
B3
B4
B5
B6
B7

L3

19

A=B

U89A
74F32

Von Microcode-ROM
/ctrlMemRamWE
/ctrlMemRamOE

1

/ctrlMemRamWE
/ctrlMemRamOE

/io_0_wr

3

/ctrlMemRamWE

2

U89B
74F32

Bisher: U90B

4

/io_0_rd

6
/ctrlMemRamOE

5

Von/zu Schaltungsteil RAM

C

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

U92
74F273

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7
/io_0_wr

/io_0_rd

5
2

Systemsignale
/reset1
clk1

/reset1
clk1

A
B
COM2 C
COM1 D
SW11
PT65-106

CLK

1

CLR

U91
74F245

SW10
PT65-106
A
B
COM2 C
COM1 D

D1
D2
D3
D4
D5
D6
D7
D8

11
/reset1

Bedienelemente
zum Debuggen

5
2

3
4
7
8
13
14
17
18

1
4
3
6

in0
in1
in2
in3

1
4
3
6

in4
in5
in6
in7

H3

RN10
VCC

1

2
3
4
5
6
7
8
9

in0
in1
in2
in3
in4
in5
in6
in7

in0
in1
in2
in3
in4
in5
in6
in7

19
1
2
3
4
5
6
7
8
9

G
DIR
A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

18
17
16
15
14
13
12
11

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

8X10KSIL9

B

A

5

4

Figure A.5: Schematic: Built-In I/O.
108

3

Q1
Q2
Q3
Q4
Q5
Q6
Q7
Q8

2
5
6
9
12
15
16
19

3

2

1

UART als Piggypack

J2
HEADER 25X2

Von Schaltungsteil RAM
ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7
bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7
/ioCE_buf
/ctrlMemRamWE_buf
/ctrlMemRamOE_buf
clk_buf
/reset_buf

ramAddress_buf0
ramAddress_buf1
ramAddress_buf2
ramAddress_buf3
ramAddress_buf4
ramAddress_buf5
ramAddress_buf6
ramAddress_buf7
bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

1
3
5
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
39
41
43
45
47
49

/ioCE_buf
/ctrlMemRamWE_buf
/ctrlMemRamOE_buf
clk_buf
/reset_buf

D

2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50

VCC

Anzeigen zum
Debuggen
8
1
2
3

U92
74F273
bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

3
4
7
8
13
14
17
18

D1
D2
D3
D4
D5
D6
D7
D8

11
/reset1

Q1
Q2
Q3
Q4
Q5
Q6
Q7
Q8

2
5
6
9
12
15
16
19

L3

8
1
2
3

CLK

1

CLR

4
5

L3

4
5

IN1 VCC
IN2
IN4
IN8
BL
LE

VCC

U93
5082_7340
C

GND

IN1 VCC
IN2
IN4
IN8
BL
LE

7

GND

6

7

VCC

U94
5082_7340

6

bus_buf0
bus_buf1
bus_buf2
bus_buf3
bus_buf4
bus_buf5
bus_buf6
bus_buf7

B

A

TIGRIS Elektronik GmbH
Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title
I/O

EDIC

3

2

Niklas Schelten

Size
A2

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

Rev
see title
Sheet

6

of

10

1

109

A Full Schematics of the EDiC

5

4

3

Von/zu Schaltungsteil RAM
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

Zu/von Kombinatorischer Teil der ALU
a0
a1
a2
a3
a4
a5
a6
a7

Von Microcode-ROM

D

/ctrlReg0WE
/ctrlReg1WE
/ctrlReg0BusOE
/ctrlReg1BusOE
ctrlRegAluSel
ctrlAluOp0
ctrlAluOp1
/ctrlAluYWE
/ctrlAluOE

/ctrlReg0WE
/ctrlReg1WE
/ctrlReg0BusOE
/ctrlReg1BusOE
ctrlRegAluSel
ctrlAluOp0
ctrlAluOp1
/ctrlAluYWE
/ctrlAluOE

U40
74F825
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7
clk1
/ctrlReg0WE
/reset1

3
4
5
6
7
8
9
10
13
14
11

U44
74F245

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

r00
r01
r02
r03
r04
r05
r06
r07

22
21
20
19
18
17
16
15
1
2
23

r00
r01
r02
r03
r04
r05
r06
r07

2
3
4
5
6
7
8
9
H4

/ctrlReg0BusOE

1
19

clk1
/ctrlReg1WE
/reset1

3
4
5
6
7
8
9
10
13
14
11

D0
D1
D2
D3
D4
D5
D6
D7
CLK
CKE
CLR

B0
B1
B2
B3
B4
B5
B6
B7

18
17
16
15
14
13
12
11

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

and0
and1
and2
and3
and4
and5
and6
and7

DIR
G

xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7

U45
74F245
Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7
OE1
OE2
OE3

r10
r11
r12
r13
r14
r15
r16
r17

22
21
20
19
18
17
16
15
1
2
23

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7

L4

U41
74F825
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

A0
A1
A2
A3
A4
A5
A6
A7

a0
a1
a2
a3
a4
a5
a6
a7

r10
r11
r12
r13
r14
r15
r16
r17

2
3
4
5
6
7
8
9
H4 1
19

/ctrlReg1BusOE

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

18
17
16
15
14
13
12
11

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

shift0
shift1
shift2
shift3
shift4
shift5
shift6
shift7

DIR
G

L4

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7
and0
and1
and2
and3
and4
and5
and6
and7
xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7
shift0
shift1
shift2
shift3
shift4
shift5
shift6
shift7
adder0
and0
xor0
shift0

U46
74ABT540
r00
r01
r02
r03
r04
r05
r06
r07

2
3
4
5
6
7
8
9
L4 1
L4 19

C

A1
A2
A3
A4
A5
A6
A7
A8

RN4
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

18
17
16
15
14
13
12
11

LED_r00
LED_r01
LED_r02
LED_r03
LED_r04
LED_r05
LED_r06
LED_r07

18
17
16
15
14
13
12
11

LED_r10
LED_r11
LED_r12
LED_r13
LED_r14
LED_r15
LED_r16
LED_r17

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

2
3
4
5
6
7
8
9
L4 1
L4 19

VCC

adder1
and1
xor1
shift1

ctrlA
ctrlA

G1
G2

U47
74ABT540
r10
r11
r12
r13
r14
r15
r16
r17

1

A1
A2
A3
A4
A5
A6
A7
A8

RN5
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

adder2
and2
xor2
shift2

VCC

adder3
and3
xor3
shift3

G1
G2

ctrlA
ctrlA

U42
74F157
r00
r01
r02
r03

2
5
11
14

r10
r11
r12
r13

3
6
10
13

ctrlRegAluSel

1
L4 15

1A
2A
3A
4A

Test
1Y
2Y
3Y
4Y

4
7
9
12

a0_src
a1_src
a2_src
a3_src

a0
a1
a2
a3

adder4
and4
xor4
shift4

1B
2B
3B
4B

adder5
and5
xor5
shift5

A/B
G

ctrlA
ctrlA

U43
74F157

ctrlRegAluSel

r04
r05
r06
r07

2
5
11
14

r14
r15
r16
r17

3
6
10
13
1
L4 15

1A
2A
3A
4A

1Y
2Y
3Y
4Y

4
7
9
12

a4_src
a5_src
a6_src
a7_src

a4
a5
a6
a7
adder6
and6
xor6
shift6

1B
2B
3B
4B
A/B
G

adder7
and7
xor7
shift7

B

ctrlA
ctrlA

JT8
BERG40

Test

a0_src
a1_src
a2_src
a3_src
a4_src
a5_src
a6_src
a7_src
alu_out0_src
alu_out1_src
alu_out2_src
alu_out3_src
alu_out4_src
alu_out5_src
alu_out6_src
alu_out7_src
A

1
3
5
7
9
11
13
15
17
19
21
23
25
27
29
31
33
35
37
39

Systemsignale
clk1
/reset1

2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40

a0
a1
a2
a3
a4
a5
a6
a7
alu_out0
alu_out1
alu_out2
alu_out3
alu_out4
alu_out5
alu_out6
alu_out7

flag_C
flagCshift

ctrlA
ctrlA

JT9
BERG26

clk1
/reset1
flagNegative_src
flagZero_src
flagCarry_src
flagOverflow_src

5

1
3
5
7
9
11
13
15
17
19

2
4
6
8
10
12
14
16
18
20

flag_V

flagNegative
flagZero
flagCarry
flagOverflow

4

Figure A.6: Schematic: Register Set + ALU output.
110

flag_C
flagCshift

flag_V

3

3

2

1

Kombinatorischer Teil der ALU

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7
and0
and1
and2
and3
and4
and5
and6
and7
xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7
shift0
shift1
shift2
shift3
shift4
shift5
shift6
shift7

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7

D

and0
and1
and2
and3
and4
and5
and6
and7
xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7
shift0
shift1
shift2
shift3
shift4
shift5
shift6
shift7

U5
74F153
adder0
and0
xor0
shift0

6
5
4
3
L4 1

adder1
and1
xor1
shift1

10
11
12
13
L4 15
ctrlAluOp0
ctrlAluOp1

14
2

1C0
1C1
1C2
1C3
1G

Test
1Y

7

alu_out0_src

alu_out0

9

alu_out1_src

alu_out1

2C0
2C1
2C2
2C3
2G

2Y

A
B

U6
74F153
adder2
and2
xor2
shift2

6
5
4
3
L4 1

adder3
and3
xor3
shift3

10
11
12
13
L4 15
ctrlAluOp0
ctrlAluOp1

14
2

C

1C0
1C1
1C2
1C3
1G

1Y

7

alu_out2_src

alu_out2

9

alu_out3_src

alu_out3

7

alu_out4_src

alu_out4

9

alu_out5_src

alu_out5

7

alu_out6_src

alu_out6

9

alu_out7_src

alu_out7

2C0
2C1
2C2
2C3
2G

2Y

A
B

U7
74F153
adder4
and4
xor4
shift4

6
5
4
3
L4 1

adder5
and5
xor5
shift5

10
11
12
13
L4 15
ctrlAluOp0
ctrlAluOp1

14
2

1C0
1C1
1C2
1C3
1G

1Y

2C0
2C1
2C2
2C3
2G

2Y

A
B

U8
74F153
adder6
and6
xor6
shift6

6
5
4
3
L4 1

adder7
and7
xor7
shift7

10
11
12
13
L4 15
ctrlAluOp0
ctrlAluOp1

14
2

1C0
1C1
1C2
1C3
1G

1Y

2C0
2C1
2C2
2C3
2G

B

2Y

A
B

U9
74F825
alu_out0
alu_out1
alu_out2
alu_out3
alu_out4
alu_out5
alu_out6
alu_out7

3
4
5
6
7
8
9
10

clk1

13
14
11

/ctrlAluYWE
/reset1

U10
74F245

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

22 alu_out_reg0
21 alu_out_reg1
20 alu_out_reg2
19 alu_out_reg3
18 alu_out_reg4
17 alu_out_reg5
16 alu_out_reg6
15 alu_out_reg7
1
2
23

/ctrlAluOE

alu_out_reg0
alu_out_reg1
alu_out_reg2
alu_out_reg3
alu_out_reg4
alu_out_reg5
alu_out_reg6
alu_out_reg7

2
3
4
5
6
7
8
9

H4

1
19

alu_out_reg0
alu_out_reg1
alu_out_reg2
alu_out_reg3
alu_out_reg4
alu_out_reg5
alu_out_reg6
alu_out_reg7

2
3
4
5
6
7
8
9

A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

18
17
16
15
14
13
12
11

DIR
G

L4

U11
74ABT540

L4 1
L4 19

flagCshift

flag_C
flagCshift

4
3
2
1
H4 15
H4 14
H4 13
12
H4
ctrlAluOp0 11
ctrlAluOp1 10
L4 9
L4 7

D0
D1
D2
D3
D4
D5
D6
D7

Y
Y

5
6

A
B
C

L4

1

alu_out0
2
alu_out1
4
alu_out2
6
alu_out3
8
alu_out4 11
alu_out5 13
alu_out6 15
alu_out7 17

LED_ao0
LED_ao1
LED_ao2
LED_ao3
LED_ao4
LED_ao5
LED_ao6
LED_ao7

18
17
16
15
14
13
12
11

LED
LED
LED
LED
LED
LED
LED
LED

2
3
4
5
6
7
8
9

1

VCC

G1
G2

G
A0
A1
A2
A3
A4
A5
A6
A7

B0
B1
B2
B3
B4
B5
B6
B7
A=B

3
5
7
9
12
14
16
18

U104A
74F04

L4

19

1

A

2
U97
74F825

G
alu_out7

flag_V

RN3
8X220R
Y1
Y2
Y3
Y4
Y5
Y6
Y7
Y8

U12
74F521

U101
74F151
flag_C

A1
A2
A3
A4
A5
A6
A7
A8

flagN
flag_Z

flag_V
H4

clk1
/ctrlAluYWE
/reset1

3
4
5
6
7
8
9
10
13
14
11

Zu Microcode-Steuerung

Test

D0
D1
D2
D3
D4
D5
D6
D7

Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

CLK
CKE
CLR

OE1
OE2
OE3

22
21
20
19
18
17
16
15
1
2
23

flagNegative_src
flagZero_src
flagCarry_src
flagOverflow_src

flagNegative
flagZero
flagCarry
flagOverflow

flagNegative
flagZero
flagCarry
flagOverflow

flagNegative
flagZero
flagCarry
flagOverflow

TIGRIS Elektronik GmbH
L4

Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title

EDIC

3

2

Niklas Schelten

Size
A1

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

ALU Ein- und Ausgänge
Rev
see title
Sheet

7

of

10

1

111

A Full Schematics of the EDiC

5

4

3

Von/zu Schaltungsteil RAM
bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

bus0
bus1
bus2
bus3
bus4
bus5
bus6
bus7

Addierer und kombinatorische Logik
U25D
74F86
ctrlAluSub

Cin

12
Y

adder0

and

and0

11
U24D
74F08

Von ALU-Eingangsregister

D

a0
a1
a2
a3
a4
a5
a6
a7

a0

A

a0
a1
a2
a3
a4
a5
a6
a7

13

12
11
13
U26D
74F08

U27D
74F32
12
11 Cout

12
11

13

13
U23D
74F86

U2A
74F86
bus0

12

1

xor0

xor

11
B

3

13

2

Von Microcode-ROM
ctrlAluSub

Shifter

U25C
74F86
Cin

9
Y

adder1

and

and1

8
U24C
74F08
a1

A

Reverse MUX

10

9
8

ctrlAluSub
reverse
rightNotLeft

ctrlAluSub

10
U26C
74F08

U27C
74F32

U13
74F157

9
10

10

2
3

9

4

a1

5
6

a2

11
10

a3

14
13

xor1

xor

8
10

5

4
Y

adder2

and

and2

6
U24B
74F08
A

L4

U26B
74F08

U27B
74F32
4
6 Cout

4
6
U23B
74F86
4

9

xor2

xor

6
B

8

a4

2
3

a5

5
6

a6

11
10

a7

14
13

5

5

bus2

4Y

5

1A
1B
2A
2B

2Y

3A
3B

3Y

4A
4B

4Y

Y

adder3

and

and3

3

a3

A

ctrlAluSub
reverse
rightNotLeft

U25A
74F86
1
U24A
74F08

2

1
3
2
U26A
74F08

U27A
74F32
1
3 Cout

1
3

2

2
U23A
74F86

U2D
74F86
bus3

1

12

xor3

xor

3
B

11

Vom Flag-Register

2

13

flagCarry

U30D
74F86
Cin

12
Y

adder4

and

and4

11
U29D
74F08
a4

A

13

12
11
13
U31D
74F08

U32D
74F32
12
11 Cout

12
11

13

13
U28D
74F86

U3A
74F86
bus4

12

1

xor4

xor

11
B

3

13

2
B

U30C
74F86
Cin

9
Y

adder5

and

and5

8
U29C
74F08
a5

A

10

9
8
10
U31C
74F08

U32C
74F32
9
8 Cout

9
8

10

10
U28C
74F86

U3B
74F86
bus5

9

4
B

xor5

xor

8
6

10

5

U30B
74F86
Cin

4
Y

adder6

and

and6

6
U29B
74F08
a6

A

5

4
6
5
U31B
74F08

U32B
74F32
4
6 Cout

4
6

5

5
U28B
74F86

U3C
74F86
bus6

4

9

xor6

xor

6
B

8

5

10
SignCout
U30A
74F86
Cin

A

1
Y

adder7

and

and7

3
U29A
74F08
a7

A

2

1
3

Bisher: U4A
U81A
74F86

2
U31A
74F08

U32A
74F32

1

1

3
3 Cout

1
3

2

2

2
U28A
74F86

U3D
74F86
bus7

1

12

3
11

B

xor

xor7

2

13

5

4

Figure A.7: Schematic: combinatorial ALU.
112

9
12

U14
74F157
1Y

1

10

Cin

7

L4

5

C

4A
4B

5

4
6

U2C
74F86

3Y

15

a2

3A
3B

4

15

Cin

2Y

G

U25B
74F86

1Y

2A
2B

G

B

6

1A
1B

A/B

bus1

a0

U23C
74F86

U2B
74F86

A/B

8

1

8 Cout

9

3

4
7
9
12

3

2

1

D

Shifter

3Y

4A
4B

4Y

9

11
10

12

14
L1 13

2Y

3A
3B

3Y

4A
4B

4Y

2
3

7

5
6

9

11
L1 10

12

14
L1 13

bus0
shift 1

1A
1B

1
11
10

12

14
13

2A
2B

2Y

3A
3B

3Y

4A
4B

4Y

1Y

2A
2B

2Y

3A
3B

3Y

4A
4B

4Y

15

4
L1

2
3

L1

5
6

7
9

11
L1 10

12

14
L1 13

1A
1B

4

shift0

shift0

7

shift1

shift1

9

shift2

shift2

12

shift3

shift3

4

shift4

shift4

7

shift5

shift5

9

shift6

shift6

12

shift7

shift7

shift0
shift1
shift2
shift3

L4
L4

U20
74F157
1Y

2A
2B

2Y

3A
3B

3Y

4A
4B

4Y

15

L4

Zu ALU-Ausgangsmultiplexer
U21
74F157

15

15
L4
U18
74F157

A/B

9

1Y

G

4Y

5
6

4

2
3

7

5
6

9

11
10

12

14
13

1A
1B

G

4

ctrlAluSub
reverse
rightNotLeft

bus2
shift 4
1
4A
4B

15
1Y

2A
2B

ctrlAluSub
reverse
rightNotLeft

L4
15

15
5
6

14
13

3Y

7

1A
1B

U22
74F157
1Y

2A
2B

2Y

3A
3B

3Y

4A
4B

4Y

shift4
shift5
shift6
shift7

C

A/B

3A
3B

7

1A
1B

12

3A
3B

2
3

1

2Y

2
3

11
10

2Y

4

ctrlAluSub
reverse
rightNotLeft

2A
2B

4

9

2A
2B

L4
U16
74F157

U19
74F157
1Y

G

4Y

5
6

A/B

1
4A
4B

7

1A
1B

1

1Y

1

14
13

3Y

2
3

bus2
shift 4

a7

14
13

1

11
10

12

3A
3B

15

15
15
a6

G

5
6

L4

U14
74F157

A/B

a5

1A
1B

11
10

2Y

L4

L4

2
3

9

2A
2B

4

G

4Y

U17
74F157
1Y

A/B

4A
4B

L4

a4

bus1
shift 2
3Y

5
6

A/B

14
13

3A
3B

7

1A
1B

G

12

2Y

2
3

G

4Y

11
10

2A
2B

4

A/B

4A
4B

9

U15
74F157
1Y

Reverse MUX

1

3Y

5
6

Shift 4 MUX

bus1
shift 2

14
13

3A
3B

7

1A
1B

1

a3

2Y

2
3

G

11
10

2A
2B

4

G

a2

1Y

A/B

5
6

Shift 2 MUX

A/B

U13
74F157

1
a1

1A
1B

A/B

2
3

G

a0

Shift 1 MUX

bus0
shift 1

ctrlAluSub
reverse
rightNotLeft

Reverse MUX

U102
74F151

Vom Flag-Register
4
3
2
1
15
14
13
12

flagCarry

bus0
bus1
bus2

shift 1
shift 2
shift 4

11
10
9
L4

7

D0
D1
D2
D3
D4
D5
D6
D7

Y
Y

5
6

A
B
C
G

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7

adder0
adder1
adder2
adder3
adder4
adder5
adder6
adder7

and0
and1
and2
and3
and4
and5
and6
and7

B

and0
and1
and2
and3
and4
and5
and6
and7

xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7

xor0
xor1
xor2
xor3
xor4
xor5
xor6
xor7

Zu Flag-Register
flagCshift

flagCshift

A

flag_V

flag_C

flag_V

flag_C

TIGRIS Elektronik GmbH
Teltowkanalstr.2
12247 Berlin

Tel: +49 (30) 7688 083-0
Web: http://www.tigris.eu
Mail: info@tigris.eu

Title

EDIC

3

2

Niklas Schelten

Size
A1

Document Number
TIGRIS Artikel-Nummer: ED101-1

Date:

Tuesday, January 11, 2022

ALU Kombinatorischer Teil
Rev
see title
Sheet

8

of

10

1

113

B Collection of assembler programs
for the EDiC

Code Example B.1: The full snake assembler program.
1
2

include "prng.s"
include "uart_16c550.s"

3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

26
27
28

SIMPLE_IO = 0xfe00
UART_RX_EMPTY = 0xfe09
UART_TX_FULL = 0xfe0a
UART_DATA = 0xfe0b
PAR1 = 0xff00
PAR2 = 0xff01
PAR3 = 0xff02
ESCAPE0 = 0x1b // \033
ESCAPE1 = 0x5b // '['
BORDER = 0x23 // '#'
SPACE = 0x20 // ' '
HEAD = 0x40 // '@'
LEFT = 0x3c // '<'
RIGHT = 0x3e // '>'
UP = 0x5e // '^'
DOWN = 0x76 // 'v'
ITEM = 0x58 // 'X'
ASCII_W = 0x77
ASCII_A = 0x61
ASCII_S = 0x73
ASCII_D = 0x64
ASCII_CAPITAL_W = 0x57

ASCII_CAPITAL_A = 0x41
ASCII_CAPITAL_S = 0x53
ASCII_CAPITAL_D = 0x44

29
30
31
32
33
34
35
36
37
38
39

// global variables
SNAKE_LENGTH
= 0x0000
SNAKE_DIRECTION = 0x0001
SNAKE_HEAD_LINE = 0x0002
SNAKE_HEAD_COL = 0x0003
SNAKE_TAIL_LINE = 0x0004
SNAKE_TAIL_COL = 0x0005
SNAKE_LEFT_LINE = 0x0006
SNAKE_LEFT_COL = 0x0007
PRNG_SEED
= 0x0008 //
,→
do not init for extra
,→
randomness

40
41
42
43

// local variables
LINE_COUNTER = 0xff00
COLUMN_COUNTER = 0xff01

44
45
46

// screen is in memory
starting from 0x0100
,→

115

B Collection of assembler programs

47

48
49
50

// one line has 256 bytes for
,→
ease of access
LINES = 24
COLUMNS = 80
COLUMNS_1 = 79

51
52

55
56
57
58
59
60
61
62
63
64

0x20.LOST_STRING = "You
,→
lost!!! Score: "

67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82

116

85
86
87

89
90
91

start:
call uart_init
// clear screen
mov r0, ESCAPE0
call uart_write
mov r0, ESCAPE1
call uart_write
mov r0, 0x32 // '2'
call uart_write
mov r0, 0x4a // 'J'
call uart_write

65
66

84

88

53
54

83

92
93
94
95
96
97
98

99
100
101
102

call createBoard
call updateItem
mainLoop:
call updateHead
cmp r0, -1
beq lost
cmp r0, 1
beq mainAteItem
call updateTail
b mainUpdateBoard
mainAteItem:
ldr r0, [SNAKE_LENGTH]
add r0, 1
str r0, [SNAKE_LENGTH]
call updateItem
mainUpdateBoard:
ldr r0, [SNAKE_LENGTH]

// move cursor to the top
// mov r0, 1 // line
// stf r0, [PAR2]
// mov r0, 0 // col
// stf r0, [PAR1]
// mov r0, BORDER
// call setScreen
ldr r0, [SNAKE_LENGTH]
str r0, [SIMPLE_IO]
// wait x ms
// mov r0, 90
// call delay_ms
call readArrow
// change direction if !=
,→
-1
cmp r0, -1
beq mainLoop
str r0, [SNAKE_DIRECTION]
b mainLoop

103
104
105

106
107
108
109
110
111
112
113
114
115
116
117
118

lost:
// set position to upper
,→
center
mov r0, 6 // line
stf r0, [PAR2]
mov r0, 27 // col
stf r0, [PAR1]
mov r0, SPACE
call setScreen
mov r0, LOST_STRING
call outputString
ldr r0, [SNAKE_LENGTH]
call outputDecimal
lostLoop:
b lostLoop

119
120
121

148

updateItem:
str r1, [0xfffe]

122
123
124
125

126
127

128
129
130
131

132
133

134
135
136
137
138

139
140
141
142

145

itemColumn:
call prng
and r0, 0x7f // limit
,→
columns
cmp r0, COLUMNS
bhs itemColumn // if out
,→
of scope redo
mov r1, r0
itemLine:
call prng
and r0, 0x1f // limit
,→
lines
cmp r0, LINES
bgt itemLine // if out of
,→
scope redo
stf r0, [PAR2]
sma r0 // line
ldr r0, [r1]
cmp r0, SPACE
bne itemColumn // if there
,→
is something at the new
,→
item position find a
,→
new one
// store new item
stf r1, [PAR1]
mov r0, ITEM
call setScreen

152
153
154
155
156

157
158
159
160
161
162
163
164
165
166

ldr r1, [0xfffe]
ret

168
169
170
171
172
173
174

Niklas Schelten

headUp:
mov r0, UP
call setScreen
ldr r0, [SNAKE_HEAD_LINE]
sub r0, 1
str r0, [SNAKE_HEAD_LINE]
b headEnd

175
176

178
179
180

// returns -1 if lost, 0 if
nothing happend and 1 if
,→
ate item
,→

ldr r0, [SNAKE_HEAD_LINE]
stf r0, [PAR2]
sma r0
ldr r0, [SNAKE_HEAD_COL]
stf r0, [PAR1]
// load correct direction
,→
char into r0
ldr r1, [SNAKE_DIRECTION]
cmp r1, 0
beq headUp
cmp r1, 1
beq headDown
cmp r1, 2
beq headRight
cmp r1, 3
beq headLeft
b headEnd // should not
happen
,→

167

177

146
147

150
151

143
144

149

updateHead:
str r1, [0xfffe]

181
182

headDown:
mov r0, DOWN
call setScreen
ldr r0, [SNAKE_HEAD_LINE]
add r0, 1
str r0, [SNAKE_HEAD_LINE]
b headEnd

183

117

B Collection of assembler programs

184
185
186
187
188
189
190

headLeft:
mov r0, LEFT
call setScreen
ldr r0, [SNAKE_HEAD_COL]
sub r0, 1
str r0, [SNAKE_HEAD_COL]
b headEnd

191
192
193
194
195
196
197
198

headRight:
mov r0, RIGHT
call setScreen
ldr r0, [SNAKE_HEAD_COL]
add r0, 1
str r0, [SNAKE_HEAD_COL]
b headEnd

203
204
205
206
207

208
209
210
211
212

213

214
215
216
217
218

118

221
222
223
224
225

227
228

headEnd:

230
231

updateTail:
str r1, [0xfffe]

232
233

235
236

ldr r1, [SNAKE_HEAD_LINE]
stf r1, [PAR2]
sma r1
ldr r1, [SNAKE_HEAD_COL]
stf r1, [PAR1]
ldr r1, [r1] // load item
,→
at new position
sts r1, [0x00]
// store & show head
mov r0, HEAD
call setScreen
// if new position is not
,→
space or item -> lost
lds r0, [0x00] // load
,→
saved item
cmp r0, SPACE
beq headSpace
cmp r0, ITEM
beq headItem
mov r0, -1

ldr r1, [0xfffe]
ret
headSpace:
mov r0, 0
ldr r1, [0xfffe]
ret
headItem:
mov r0, 1
ldr r1, [0xfffe]
ret

229

234

201
202

220

226

199
200

219

237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252

ldr r0, [SNAKE_TAIL_LINE]
str r0, [SNAKE_LEFT_LINE]
stf r0, [PAR2]
sma r0
ldr r0, [SNAKE_TAIL_COL]
str r0, [SNAKE_LEFT_COL]
stf r0, [PAR1]
// load direction char
ldr r1, [r0]
mov r0, SPACE
call setScreen
cmp r1, UP
beq tailUp
cmp r1, DOWN
beq tailDown
cmp r1, RIGHT
beq tailRight
cmp r1, LEFT
beq tailLeft
b tailEnd // should not
,→
happen

253
254
255

tailUp:
ldr r1, [SNAKE_TAIL_LINE]

256
257
258

sub r1, 1
str r1, [SNAKE_TAIL_LINE]
b tailEnd

259
260
261
262
263
264

267
268
269
270

tailDown:
ldr r1, [SNAKE_TAIL_LINE]
add r1, 1
str r1, [SNAKE_TAIL_LINE]
b tailEnd

273
274
275
276

tailLeft:
ldr r1, [SNAKE_TAIL_COL]
sub r1, 1
str r1, [SNAKE_TAIL_COL]
b tailEnd

279
280

tailRight:
ldr r1, [SNAKE_TAIL_COL]
add r1, 1
str r1, [SNAKE_TAIL_COL]
b tailEnd

283
284

tailEnd:
ldr r1, [0xfffe]
ret

287
288
289
290
291
292
293

300
301
302

304
305
306
307
308

310

createBoard:
str r0, [0xfffe]
str r1, [0xfffd]

312
313

315
316
317

319
320
321
322

// init snake
mov r0, 4
str r0, [SNAKE_LENGTH]
mov r0, 2
str r0, [SNAKE_DIRECTION]
mov r0, 12 // center
str r0, [SNAKE_HEAD_LINE]
mov r0, 40 #center

Niklas Schelten

// move to home position
mov r0, ESCAPE0
call uart_write
mov r0, ESCAPE1
call uart_write
mov r0, 0x48 // 'H'
call uart_write

311

318

285
286

299

314

281
282

298

309

277
278

296

str r0, [SNAKE_HEAD_COL]
mov r0, 12
str r0, [SNAKE_TAIL_LINE]
mov r0, 37
str r0, [SNAKE_TAIL_COL]
mov r0, 12
str r0, [SNAKE_LEFT_LINE]
mov r0, 36
str r0, [SNAKE_LEFT_COL]

303

271
272

295

297

265
266

294

// first and last line is
full border
,→
mov r1, 0
createLine0Loop:
sma 1
mov r0, BORDER
str r0, [r1]
call uart_write
add r1, 1
cmp r1, COLUMNS
blt createLine0Loop

323
324
325
326
327

mov r0, 0x0a // LF
call uart_write
mov r0, 0x0d // CR
call uart_write

328
329

// line 2 to 23 have first
,→
and last column border

119

B Collection of assembler programs

353

mov r1, 2 // skip first
364
,→
line
str r1, [LINE_COUNTER]
365
createLineLoop:
366
// load mar1 with line
367
,→
space
368
sma r1
369
mov r1, 0
370
mov r0, BORDER
371
str r0, [r1]
372
call uart_write
373
add r1, 1
374
// loop through line
375
,→
(1-79) and store space 376
createColumnLoop:
377
ldr r0, [LINE_COUNTER]
378
sma r0
379
mov r0, SPACE
380
str r0, [r1]
381
382
call uart_write
add r1, 1
383
cmp r1, COLUMNS_1
384
blt createColumnLoop
385
// store end border
386
mov r0, BORDER
387
str r0, [r1]
388
call uart_write
389

354

390

330

331
332
333

334
335
336
337
338
339
340

341
342
343
344
345
346
347
348
349
350
351
352

355
356
357
358

mov r0, 0x0a // LF
call uart_write
mov r0, 0x0d // CR
call uart_write

359
360
361
362
363

391
392
393
394
395

ldr r1, [LINE_COUNTER]
add r1, 1
str r1, [LINE_COUNTER]
cmp r1, LINES

396

// draw last line
mov r1, 0
createLineLastLoop:
sma LINES
mov r0, BORDER
str r0, [r1]
call uart_write
add r1, 1
cmp r1, COLUMNS
blt createLineLastLoop
// draw snake
ldr r0, [SNAKE_HEAD_LINE]
stf r0, [PAR2]
ldr r0, [SNAKE_HEAD_COL]
stf r0, [PAR1]
mov r0, HEAD
call setScreen
mov r1, 1
snakeBody:
ldr r0, [SNAKE_HEAD_LINE]
stf r0, [PAR2]
ldr r0, [SNAKE_HEAD_COL]
sub r0, r1
stf r0, [PAR1]
mov r0, RIGHT
call setScreen
add r1, 1
cmp r1, 3
ble snakeBody

397
398
399
400

120

blt createLineLoop // skip
,→
last line

ldr r0, [0xfffe]
ldr r1, [0xfffd]
ret

401

435

402

436

403

404
405
406

// r0: char, PAR1: col, PAR2:
,→
line
setScreen:
str r0, [0xfffe]
str r1, [0xfffd]

407
408
409
410
411
412

415
416
417
418
419

420
421
422
423
424

425
426
427

// store
ldr r1, [PAR2]
sma r1
ldr r1, [PAR1]
str r0, [r1]

430

// decimal needs to be one
,→
based
mov r0, ESCAPE0
call uart_write
mov r0, ESCAPE1
call uart_write
ldr r0, [PAR2] // line is
,→
already one based
call outputDecimal
mov r0, 0x3b // ';'
call uart_write
ldr r0, [PAR1]
add r0, 1 // column is not
,→
one based
call outputDecimal
mov r0, 0x48 // 'H'
call uart_write
ldr r0, [0xfffe]
call uart_write

441

443

444

445

447
448
449
450
451

452
453

454

455

mov r1, 100
stf r1, [PAR1]
call divMod // r0 / 100
ldf r1, [PAR1] // mod
,→
result
add r0, 0x30 // make to
,→
char
call uart_write
mov r0, r1 // remainder is
,→
parameter for next
,→
divMod
mov r1, 10
stf r1, [PAR1]
call divMod
ldf r1, [PAR1]
add r0, 0x30 // make to
,→
char
call uart_write
mov r0, r1 // last char to
,→
output
add r0, 0x30 // make to
,→
char
call uart_write

456
457
458

460
461
462

ldr r1, [0xfffd]

433
434

440

ldr r1, [0xfffe]
ret

459

431
432

439

446

428
429

438

442

413
414

437

// r0 is parameter
outputDecimal:
str r1, [0xfffe]

463
464

ret

Niklas Schelten

465

// r0: address of string
outputString:
str r1, [0xfffe]
sts r0, [0x00]
mov r1, 0
outputStringLoop:

121

B Collection of assembler programs

466
467
468
469
470
471
472
473
474

lds r0, [0x00]
sma r0
ldr r0, [r1]
cmp r0, 0
beq outputStringEnd
call uart_write
add r1, 1
cmp r1, 255
bne outputStringLoop

501

502
503
504
505
506
507

475
476

outputStringEnd:

477
478
479

508
509

ldr r1, [0xfffe]
ret

510
511

480

512

481

513

493

// r0 / PAR1
514
// result: r0 -> div, *PAR1 -> 515
,→
mod
516
divMod:
517
str r1, [0xfffe]
518
mov r1, 0
519
divLoop:
520
add r1, 1
521
sub r0, [PAR1]
522
bpl divLoop // positive or
523
,→
zero (N Clear)
524
// executing one step too
525
,→
much, undo it
526
add r0, [PAR1]
527
sub r1, 1
528

494

529

482
483

484
485
486
487
488
489
490

491

492

495
496
497
498

str r0, [PAR1]
mov r0, r1
ldr r1, [0xfffe]
ret

499
500

122

530

cmp r0, ESCAPE0
bne readArrowLoop // make
,→
sure to empty the fifo

531
532
533

// r0 is return value:

// -1 for nothing, 0 for up,
,→
1 for down, 2 for right,
,→
3 for left
readArrow:
str r1, [0xfffe]
readArrowLoop:
call uart_read
cmp r0, 0
beq readArrowNothing // no
,→
char received
// up
cmp r0, ASCII_W
beq readArrowUp
cmp r0, ASCII_CAPITAL_W
beq readArrowUp
// left
cmp r0, ASCII_A
beq readArrowLeft
cmp r0, ASCII_CAPITAL_A
beq readArrowLeft
// down
cmp r0, ASCII_S
beq readArrowDown
cmp r0, ASCII_CAPITAL_S
beq readArrowDown
// right
cmp r0, ASCII_D
beq readArrowRight
cmp r0, ASCII_CAPITAL_D
beq readArrowRight

534

call uart_read
cmp r0, 0
beq readArrowNothing

535
536

cmp r0, ESCAPE1
bne readArrowLoop

537
538
539
540
541
542
543
544
545

546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563

564
565

mov r0, 2
ret

566

call uart_read
cmp r0, 0x41 // A
blt readArrowLoop
cmp r0, 0x44 // D
bgt readArrowLoop
sub r0, 0x41 // return 0-4
ret
// -1 for nothing, 0 for up,
,→
1 for down, 2 for right,
,→
3 for left
readArrowNothing:
ldr r1, [0xfffe]
mov r0, -1
ret
readArrowUp:
ldr r1, [0xfffe]
mov r0, 0
ret
readArrowLeft:
ldr r1, [0xfffe]
mov r0, 3
ret
readArrowDown:
ldr r1, [0xfffe]
mov r0, 1
ret
readArrowRight:
ldr r1, [0xfffe]

567
568
569

// r0: delay in ms
delay_ms:
sts r0, [0x00]

570
571

delay_ms_outer_loop:

572
573

574

575

576
577
578
579
580

// 2MHz clock -> 1ms is
,→
2000cycle
// per loop 4+4+3+3=14
,→
cycles (below)
// -> 198.6 times 10
,→
cycles per iteration
mov r0, 0
delay_ms_loop:
add r0, 1 // 4 cycles
cmp r0, 199 // 3 cycles
blo delay_ms_loop // 3
,→
cycles

581
582

583
584

585

586

lds r0, [0x00] // 4
,→
cycles
sub r0, 1 // 4 cycles
sts r0, [0x00] // 3
,→
cycles
bhi delay_ms_outer_loop //
,→
3 cycles
ret

Code Example B.2: The PRNG assembler program “prng.s” used in the
snake program in code example B.1.
1
2

PRNG_SEED = 0x0000
SIMPLE_IO = 0xfe00

3

Niklas Schelten

123

B Collection of assembler programs
prng:
ldr r0, [PRNG_SEED]
subs r0, 0
beq prngDoEor
lsl r0, 1
beq prngNoEor
bcc prngNoEor
prngDoEor:
xor r0, 0x1d
prngNoEor:
str r0, [PRNG_SEED]
ret

4
5
6
7
8
9
10
11
12
13
14
15
16

start:
mov r0, 0
str r0, [PRNG_SEED]
prng_loop:
call prng
str r0, [SIMPLE_IO]
b prng_loop

17
18
19
20
21
22
23

Code Example B.3: The utility library for the UART extension card of the
EDiC with the 16c550 UART Transceiver.
1
2
3
4
5
6
7
8
9
10
11

UART_DAT = 0xfe08
UART_IER = 0xfe09
UART_IIR = 0xfe0a
UART_FCR = 0xfe0a
UART_LCR = 0xfe0b
UART_MCR = 0xfe0c
UART_LSR = 0xfe0d
UART_MSR = 0xfe0e
UART_SCR = 0xfe0f
UART_DLL_DLAB = 0xfe08
UART_DLM_DLAB = 0xfe09

12
13

124

14
15

16

17
18
19
20

21
22

UART_DIV = 10 // 19200 baud

// UART_DIV = 20 // 9600 baud
UART_FILL_AMOUNT = 60 //
19200 baud
,→
// UART_FILL_AMOUNT = 30 //
,→
9600 baud
uart_init:
// line control register
// 8bit, 2 stopbits, no
,→
parity, dlab active:
// 0b10xx_0111
// 8bit, 1 stopbit, no
,→
parity, dlab active:

23
24
25

// 0b10xx_0011
mov r0, 0x87
str r0, [UART_LCR]

26
27
28
29
30
31

// divisor latch access
mov r0, 0x00
str r0, [UART_DLM_DLAB]
mov r0, UART_DIV
str r0, [UART_DLL_DLAB]

34
35

38

39
40
41

59

61

62

// lcr as above but dlab
,→
inactive
mov r0, 0x07
str r0, [UART_LCR]

64

44

45
46

66
67

49

50
51
52
53

// fifo control register
// fifo enable, reset tx
,→
and rx fifo
// 0b00xx_x111
mov r0, 0x07
str r0, [UART_FCR]
// interupt enable register
// clear all interupts ->
,→
fifo polled mode
mov r0, 0x00
str r0, [UART_IER]

69
70
71

// modem control register
// assert dtr, deassert rts
,→
(should be asserted?),
// 0bxxx0_xx01
mov r0, 0x01
str r0, [UART_MCR]
ret

56

uart_write:
sts r1, [0x00]
call uart_write_inner

72
73

74

cmp r0, 0x20 // if less
,→
than 0x20 -> send fill
,→
null bytes
bge uart_write_end

75
76
77
78
79

54
55

lds r1, [0x00]
ret

68

47
48

str r0, [UART_DAT]

65

42
43

uart_write_loop:
ldr r1, [UART_LSR]
and r1, 0x20 // bit 5,
,→
fifo empty (not full?)
,→
-> if 1, can accept
,→
new data
beq uart_write_loop

63

36
37

sts r1, [0x00]

58

60

32
33

57

80
81
82

mov r0, 0x00
mov r1, UART_FILL_AMOUNT
uart_write_fill_loop:
call uart_write_inner
sub r1, 1
cmp r1, 0
bhi uart_write_fill_loop

83
84
85
86

uart_write_end:
lds r1, [0x00]
ret

87

// r0 is byte to write
uart_write_inner:

Niklas Schelten

88
89

// r0 is byte to write

125

B Collection of assembler programs

90
91
92

93

uart_read:
ldr r0, [UART_LSR]
and r0, 0x01 // bit 0, fifo
,→
not empty -> 1 if data
exists
,→
beq uart_read_0

94
95
96
97
98
99

108

109
110
111

ldr r0, [UART_DAT]
ret
uart_read_0:
mov r0, 0
ret

113
114

116
117

101

119

104

// r0 is byte to write
uart_read_busy:
sts r1, [0x00]

105
106
107

126

120
121
122
123

uart_read_busy_loop:
ldr r1, [UART_LSR]

lds r1, [0x00]
ret

115

118

103

ldr r0, [UART_DAT]

112

100

102

and r1, 0x01 // bit 0,
,→
fifo not empty -> 1
,→
if data exists
beq uart_read_busy_loop

124
125

start:
call uart_init
uart_loop:
call uart_read
str r0, [0xfe00]
cmp r0, 0
beq uart_loop
call uart_write
b uart_loop

